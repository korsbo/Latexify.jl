var documenterSearchIndex = {"docs":
[{"location":"#Latexify.jl-1","page":"Latexify.jl","title":"Latexify.jl","text":"","category":"section"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"Latexify.jl is a package which supplies functions for producing LaTeX formatted strings from Julia objects. The package allows for latexification of a many different kinds of Julia object and it can output several different LaTeX or Markdown environments.","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"A small teaser:","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"using Latexify\ncopy_to_clipboard(true)\nm = [2//3 \"e^(-c*t)\" 1+3im; :(x/(x+k_1)) \"gamma(n)\" :(log10(x))]\nlatexify(m)","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"beginequation\nleft\nbeginarrayccc\nfrac23  e^ - c cdot t  1+3textiti \nfracxx + k_1  Gammaleft( n right)  log_10left( x right) \nendarray\nright\nendequation","category":"page"},{"location":"#Supported-input-1","page":"Latexify.jl","title":"Supported input","text":"","category":"section"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"This package supplies functionality for latexifying objects of the following types:","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"Expressions,\nStrings,\nNumbers (including rational and complex),\nMissings' Missing type,\nSymbols,\nSymbolic expressions from SymEngine.jl,\nDataFrame from DataFrames.jl,\nAny shape of array containing a mix of any of the above types,\nParameterizedFunctions from DifferentialEquations.jl,\nReactionNetworks from DifferentialEquations.jl","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"Example:","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"julia> str = \"x/(2*k_1+x^2)\"\njulia> latexify(str)\n","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"fracx2 cdot k_1 + x^2","category":"page"},{"location":"#Supported-output-1","page":"Latexify.jl","title":"Supported output","text":"","category":"section"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"Latexify has support for generating a range of different LaTeX environments. The main function of the package, latexify(), automatically picks a suitable output environment based on the type(s) of the input. However, you can override this by passing the keyword argument env =. The following environments are available:","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"environment env= description\nno env :raw Latexifies an object and returns a LaTeX formatted string. If the input is an array it will be recursed and all its elements latexified. This function does not surround the resulting string in any LaTeX environments.\nInline :inline latexify the input and surround it with $$ for inline rendering.\nAlign :align Latexifies input and surrounds it with an align environment. Useful for systems of equations and such fun stuff.\nEquation :equation or :eq Latexifies input and surrounds it with an equation environment.\nArray :array Latexify the elements of an Array or a Dict and output them in a LaTeX array.\nTabular :table or :tabular Latexify the elements of an array and output a tabular environment. Note that tabular is not supported by MathJax and will therefore not be rendered in Jupyter, etc.\nMarkdown Table :mdtable Output a Markdown table. This will be rendered nicely by Jupyter, etc.\nMarkdown Text :mdtext Output and render any string which can be parsed into Markdown. This is really nothing but a call to Base.Markdown.parse(),  but it does the trick. Useful for rendering bullet lists and such things.\nChemical arrow notation :chem, :chemical, :arrow or :arrows Latexify an AbstractReactionNetwork to LaTeX formatted chemical arrow notation using mhchem.","category":"page"},{"location":"#Modifying-the-output-1","page":"Latexify.jl","title":"Modifying the output","text":"","category":"section"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"Some of the different outputs can be modified using keyword arguments. You can for example transpose an array with transpose=true or specify a header of a table or mdtable with header=[]. For more options, see the List of possible arguments.","category":"page"},{"location":"#Printing-vs-displaying-1","page":"Latexify.jl","title":"Printing vs displaying","text":"","category":"section"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"latexify() returns a LaTeXString. Using display() on such a string will try to render it.","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(\"x/y\") |> display","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"fracxy","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"Using print() will output text which is formatted for latex.","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(\"x/y\") |> print","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"$\\frac{x}{y}$","category":"page"},{"location":"#Number-formatting-1","page":"Latexify.jl","title":"Number formatting","text":"","category":"section"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"You can control the formatting of numbers by passing the keyword argument fmt. This will be passed on to Printf, have a read there for more information.","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"Examples:","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(12345.678; fmt=\"%.1e\")","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"12e+04","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"latexify([12893.1 1.328e2; \"x/y\" 7832//2378]; fmt=\"%.1e\")","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"beginequation\nleft\nbeginarraycc\n13e+04  13e+02 \nfracxy  frac39161189 \nendarray\nright\nendequation","category":"page"},{"location":"#Automatic-copying-to-clipboard-1","page":"Latexify.jl","title":"Automatic copying to clipboard","text":"","category":"section"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"The strings that you would see when using print on any of the above functions can be automatically copied to the clipboard if you so specify. Since I do not wish to mess with your clipboard without you knowing it, this feature must be activated by you.","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"To do so, run","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"copy_to_clipboard(true)","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"To once again disable the feature, pass false to the same function.","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"The copying to the clipboard will now occur at every call to a Latexify.jl function, regardless of how you chose to display the output.","category":"page"},{"location":"#Automatic-displaying-of-result-1","page":"Latexify.jl","title":"Automatic displaying of result","text":"","category":"section"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"You can toggle whether the result should be automatically displayed. Instead of","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(\"x/y\") |> display\n## or\ndisplay( latexify(\"x/y\") )","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"one can toggle automatic display by:","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"auto_display(true)","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"after which all calls to latexify will automatically be displayed. This can be rather convenient, but it can also cause a lot of unwanted printouts if you are using latexify in any form of loop. You can turn off this behaviour again by passing false to the same function.","category":"page"},{"location":"#Setting-your-own-defaults-1","page":"Latexify.jl","title":"Setting your own defaults","text":"","category":"section"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"If you get tired of specifying the same keyword argument over and over in a session, you can just reset its default:","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"set_default(fmt = \"%.2f\", convert_unicode = false)","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"Note that this changes Latexify.jl from within and should therefore only be used in your own Julia sessions (do not call this from within your packages). ","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"The calls are additive so that a new call with ","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"set_default(cdot = false)","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"will not cancel out the changes we just made to fmt and convert_unicode. ","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"To view your changes, use","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"get_default()","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"and to reset your changes, use","category":"page"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"reset_default()","category":"page"},{"location":"#Legacy-support-1","page":"Latexify.jl","title":"Legacy support","text":"","category":"section"},{"location":"#","page":"Latexify.jl","title":"Latexify.jl","text":"Latexify.jl has stopped supporting Julia versions older than 0.7. This does not mean that you cannot use Latexify with earlier versions, just that these will not get new features. Latexify.jl's release v0.4.1 was the last which supported Julia 0.6. Choose that release in the dropdown menu if you want to see that documentation.","category":"page"},{"location":"tutorials/recipes/#Recipes-1","page":"Recipes","title":"Recipes","text":"","category":"section"},{"location":"tutorials/recipes/#","page":"Recipes","title":"Recipes","text":"Recipes provides a concise means of extending Latexify.jl to work with types of your own making or of other packages. The @latexrecipe macro allows you to specify how a an argument type (or a set of types) should be pre-processed before they are passed to the standard latexify function. Also, it allows you to define both new keyword arguments as well as to set the defaults of pre-existing ones. The main power of this macro is that is defines the necessary functions within Latexify.jl itself, as opposed to within the module where it is called. ","category":"page"},{"location":"tutorials/recipes/#","page":"Recipes","title":"Recipes","text":"The recipe syntax closely follow that of the Plots.jl recipes and, indeed, most of the code is copied and adapted from them (cred to the authors!). ","category":"page"},{"location":"tutorials/recipes/#","page":"Recipes","title":"Recipes","text":"So. The easiest way to explain it is by showing an example where we define a recipe for our type MyType. ","category":"page"},{"location":"tutorials/recipes/#","page":"Recipes","title":"Recipes","text":"using Latexify\n\nstruct MyType \n   vector::Vector\nend","category":"page"},{"location":"tutorials/recipes/#","page":"Recipes","title":"Recipes","text":"@latexrecipe function f(x::MyType; reverse=false)\n    ## we can access the input object and perform operations like in a normal function.\n    vec = x.vector\n    if reverse\n        vec = vec[end:-1:1]\n    end\n\n    ## we can define defult keyword arguments to be passed along to latexify \n    ## using an arrow notation, --> \n    env --> :array\n    transpose --> true\n    ## These can be overridden by the keyword arguments passed to the latexify function.\n\n    ## If you use the := operator to specify a value it cannot be overridden.\n    fmt := \"%.2f\"\n\n    ## The return value should be something that latexify already knows how to work with.\n    ## In this case, we have a simple vector which is fine!\n    return vec\nend","category":"page"},{"location":"tutorials/recipes/#","page":"Recipes","title":"Recipes","text":"mytype = MyType([1, 2, 3])\n\nlatexify(mytype; reverse=true)","category":"page"},{"location":"tutorials/recipes/#","page":"Recipes","title":"Recipes","text":"beginequation\nleft\nbeginarrayc\n300 \n200 \n100 \nendarray\nright\nendequation","category":"page"},{"location":"tutorials/recipes/#","page":"Recipes","title":"Recipes","text":"The required signature of the macro is","category":"page"},{"location":"tutorials/recipes/#","page":"Recipes","title":"Recipes","text":"@latexrecipe function f(x::MyType, ...; ...)\n    return something\nend","category":"page"},{"location":"tutorials/recipes/#","page":"Recipes","title":"Recipes","text":"Here, the function name is unimportant, but the type signature is key.  There must also be a return statement which returns something that base Latexify already works with (Arrays, Tuples, Numbers, Symbols, Strings, etc.) The special notation kwarg --> value resets the default value of a keyword argument for your specific inputs. This will be overridden if the keyword argument in quesion is specified in a call to latexify.  To disallow this overriding, use kwarg := value instead.","category":"page"},{"location":"tutorials/recipes/#","page":"Recipes","title":"Recipes","text":"The use of @latexrecipe to redefine how an already supported type should be interpreted is highly discouraged. There is (currently) nothing in place to forbid this but it could mess up how latexify works with other packages. Disregarding this in your own sessions is one thing, but doing it in a package could cause very difficult issues for the users of your package. ","category":"page"},{"location":"tutorials/recipes/#","page":"Recipes","title":"Recipes","text":"If a recipe is defined within a module, everything should just work without the need to export anything. ","category":"page"},{"location":"tutorials/parameterizedfunctions/#Use-with-ParameterizedFunctions-1","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"","category":"section"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"In the latexalign tutorial I mentioned that one can use latexalign directly on a ParameterizedFunction. Here, I make a somewhat more convoluted and hard-to-read example (you'll soon se why):","category":"page"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"using Latexify\nusing ParameterizedFunctions\ncopy_to_clipboard(true)\n\node = @ode_def positiveFeedback begin\n    dx = y*y*y/(k_y_x + y) - x - x\n    dy = x^n_x/(k_x^n_x + x^n_x) - y\nend k_y k_x n_x\n\nlatexify(ode)","category":"page"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginalign\nfracdxdt = fracy cdot y cdot yk_y_x + y - x - x \nfracdydt = fracx^n_xk_x^n_x + x^n_x - y \nendalign","category":"page"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"This is pretty nice, but there are a few parts of the equation which could be reduced. Using a keyword argument, you can utilise the SymEngine.jl to reduce the expression before printing.","category":"page"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"latexify(ode, field=:symfuncs)","category":"page"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginalign\nfracdxdt = -2 cdot x + fracy^3k_y_x + y \nfracdydt =  - y + fracx^n_xk_x^n_x + x^n_x \nendalign","category":"page"},{"location":"tutorials/parameterizedfunctions/#Side-by-side-rendering-of-multiple-system.-1","page":"Use with ParameterizedFunctions","title":"Side-by-side rendering of multiple system.","text":"","category":"section"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"A vector of ParameterizedFunctions will be rendered side-by-side:","category":"page"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"ode2 = @ode_def negativeFeedback begin\n    dx = y/(k_y + y) - x\n    dy = k_x^n_x/(k_x^n_x + x^n_x) - y\nend k_y k_x n_x\n\nlatexify([ode, ode2])","category":"page"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginalign\nfracdxdt  =  fracy cdot y cdot yk_y_x + y - x - x    fracdxdt  =  fracyk_y + y - x    \nfracdydt  =  fracx^n_xk_x^n_x + x^n_x - y    fracdydt  =  frack_x^n_xk_x^n_x + x^n_x - y    \nendalign","category":"page"},{"location":"tutorials/parameterizedfunctions/#Visualise-your-parameters.-1","page":"Use with ParameterizedFunctions","title":"Visualise your parameters.","text":"","category":"section"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"Another thing that I have found useful is to display the parameters of these functions. The parameters are usually in a vector, and if it is somewhat long, then it can be annoying to try to figure out which element belongs to which parameter. There are several ways to solve this. Here are two:","category":"page"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"## lets say that we have some parameters\nparam = [3.4,5.2,1e-2]\nlatexify(ode.params, param)","category":"page"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginalign\nk_y = 34 \nk_x = 52 \nn_x = 001 \nendalign","category":"page"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"or","category":"page"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"latexify([ode.params, param]; env=:array, transpose=true)","category":"page"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginequation\nleft\nbeginarrayccc\nk_y  k_x  n_x \n34  52  001 \nendarray\nright\nendequation","category":"page"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"signif.() is your friend if your parameters have more significant numbers than you want to see.","category":"page"},{"location":"tutorials/parameterizedfunctions/#Get-the-jacobian,-hessian,-etc.-1","page":"Use with ParameterizedFunctions","title":"Get the jacobian, hessian, etc.","text":"","category":"section"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"ParameterizedFunctions symbolically calculates the jacobian, inverse jacobian, hessian, and all kinds of goodness. Since they are available as arrays of symbolic expressions, which are latexifyable, you can render pretty much all of them.","category":"page"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"latexify(ode.symjac)","category":"page"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginequation\nleft\nbeginarraycc\n-2  frac3 cdot y^2k_y_x + y - fracy^3left( k_y_x + y right)^2 \nfracx^-1 + n_x cdot n_xk_x^n_x + x^n_x - fracx^-1 + 2 cdot n_x cdot n_xleft( k_x^n_x + x^n_x right)^2  -1 \nendarray\nright\nendequation","category":"page"},{"location":"tutorials/parameterizedfunctions/#Available-options-1","page":"Use with ParameterizedFunctions","title":"Available options","text":"","category":"section"},{"location":"tutorials/parameterizedfunctions/#","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :ParameterizedFunction in arg.types || :Any in arg.types]\nlatexify(args, env=:mdtable, types=false)","category":"page"},{"location":"tutorials/DiffEqBiological/#Use-with-@reaction_network-from-DiffEqBiological.jl.-1","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"","category":"section"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"Latexify.jl has methods for dealing with AbstractReactionNetworks. For more information regarding this DSL, turn to its docs. The latexify end of things are pretty simple: feed a reaction network to latexify() and let it do its magic.","category":"page"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"using DiffEqBiological\nusing Latexify\ncopy_to_clipboard(true)\n\n@reaction_func hill2(x, v, k) = v*x^2/(k^2 + x^2)\n\nrn = @reaction_network MyRnType begin\n  hill2(y, v_x, k_x), 0 --> x\n  p_y, 0 --> y\n  (d_x, d_y), (x, y) --> 0\n  (r_b, r_u), x â†” y\nend v_x k_x p_y d_x d_y r_b r_u\n\nlatexify(rn)","category":"page"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"beginalign\nfracdxdt = fracv_x cdot y^2k_x^2 + y^2 - d_x cdot x - r_b cdot x + r_u cdot y \nfracdydt = p_y - d_y cdot y + r_b cdot x - r_u cdot y \nendalign","category":"page"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"The method has a keyword for choosing between outputting the ODE or the noise term. While it is not obvious from the latexify output, the noise in the reaction network is correlated.","category":"page"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"latexify(rn; noise=true)","category":"page"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"beginalign\nfracdxdt = sqrtfracv_x cdot y^2k_x^2 + y^2 - sqrtd_x cdot x - sqrtr_b cdot x + sqrtr_u cdot y \nfracdydt = sqrtp_y - sqrtd_y cdot y + sqrtr_b cdot x - sqrtr_u cdot y \nendalign","category":"page"},{"location":"tutorials/DiffEqBiological/#Chemical-arrow-notation-1","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Chemical arrow notation","text":"","category":"section"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"DiffEqBiologicals reaction network is all about chemical arrow notation, so why should we not be able to render arrows?","category":"page"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"Use latexify's env keyword argument to specify that you want :chemical (or the equivalent :arrow, :arrows or :chem).","category":"page"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"latexify(rn; env=:chemical)","category":"page"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"\\begin{align} \\require{mhchem} \\ce{ \\varnothing &->[\\frac{v{x} \\cdot y^{2}}{k{x}^{2} + y^{2}}] x}\\\\\n\\ce{ \\varnothing &->[p{y}] y}\\\\\n\\ce{ x &->[d{x}] \\varnothing}\\\\\n\\ce{ y &->[d{y}] \\varnothing}\\\\\n\\ce{ x &<=>[{r{b}}][{r_{u}}] y}\\\\\n\\end{align}","category":"page"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"The default output is meant to be rendered directly on the screen. This rendering is typically done by MathJax. To get the chemical arrow notation to render automatically, I have included a MathJax command (\\require{mhchem}) in the output string. If you want to use the output in a real LaTeX document, you can pass the keyword argument mathjax=false and this extra command will be omitted. In such case you should also add \\usepackage{mhchem} to the preamble of your latex document.","category":"page"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"Another keyword argument that may be of use is expand=false (defaults to true). This determines whether your functions should be expanded or not. Also, starred=true will change the outputted latex environment from align to align*. This results in the equations not being numbered.","category":"page"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"latexify(rn; env=:chemical, expand=false, starred=true)","category":"page"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"beginalign*\nrequiremhchem\nce varnothing -mathrmhill2left( y v_x k_x right) x\nce varnothing -p_y y\nce x -d_x varnothing\nce y -d_y varnothing\nce x =r_br_u y\nendalign*","category":"page"},{"location":"tutorials/DiffEqBiological/#Available-options-1","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Available options","text":"","category":"section"},{"location":"tutorials/DiffEqBiological/#Align-1","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Align","text":"","category":"section"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if (:ReactionNetwork in arg.types || :Any in arg.types) && :align in arg.env]\nlatexify(args, env=:mdtable, types=false)","category":"page"},{"location":"tutorials/DiffEqBiological/#Arrow-notation-1","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Arrow notation","text":"","category":"section"},{"location":"tutorials/DiffEqBiological/#","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if (:ReactionNetwork in arg.types || :Any in arg.types) && :arrow in arg.env]\nlatexify(args, env=:mdtable, types=false)","category":"page"},{"location":"arguments/#List-of-possible-arguments-1","page":"List of possible arguments","title":"List of possible arguments","text":"","category":"section"},{"location":"arguments/#Align-1","page":"List of possible arguments","title":"Align","text":"","category":"section"},{"location":"arguments/#","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :align in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Equation-1","page":"List of possible arguments","title":"Equation","text":"","category":"section"},{"location":"arguments/#","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :equation in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Array-1","page":"List of possible arguments","title":"Array","text":"","category":"section"},{"location":"arguments/#","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :array in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Tabular-1","page":"List of possible arguments","title":"Tabular","text":"","category":"section"},{"location":"arguments/#","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :tabular in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Markdown-Table-1","page":"List of possible arguments","title":"Markdown Table","text":"","category":"section"},{"location":"arguments/#","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :mdtable in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Inline-and-raw-1","page":"List of possible arguments","title":"Inline and raw","text":"","category":"section"},{"location":"arguments/#","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :raw in arg.env || :inline in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Chemical-arrow-notation-1","page":"List of possible arguments","title":"Chemical arrow notation","text":"","category":"section"},{"location":"arguments/#","page":"List of possible arguments","title":"List of possible arguments","text":"Available with ReactionNetworks from DiffEqBiological.","category":"page"},{"location":"arguments/#","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :arrow in arg.env]\nlatexify(args, env=:mdtable, types=false)","category":"page"},{"location":"tutorials/inner_workings/#Inner-workings-1","page":"Inner workings","title":"Inner workings","text":"","category":"section"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"This package contains a large number of methods, but two of these are of special importance. These are:","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"latexraw(ex::Expr)","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"and","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"latexoperation(ex::Expr, prevOp::AbstractArray)","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"These two methods are involved with all conversions to LaTeX equations. ","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"latexraw(ex::Expr) utilises Julias homoiconicity to infer the correct latexification of an expression by recursing through the expression tree. Whenever it hits the end of a recursion it passes the last expression to latexoperation(). By the nature of this recursion, this expression is one which only contains symbols or strings.","category":"page"},{"location":"tutorials/inner_workings/#Explanation-by-example-1","page":"Inner workings","title":"Explanation by example","text":"","category":"section"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"Let's define a variable of the expression type:","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"julia> ex = :(x + y/z)","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"This expression has a field which contains the first operation which must be done, along with the objects that this operation will operate on:","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"julia> ex.args\n\n3-element Array{Any,1}:\n :+      \n :x      \n :(y / z)","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"The first two element are both Symbols, while the third one is an expression:","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"julia> typeof.(ex.args)\n\n3-element Array{DataType,1}:\n Symbol\n Symbol\n Expr","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"Since at least one of these elements is an expression, the next step of the recursive algorithm is to dive into that expression:","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"julia> newEX = ex.args[3]\njulia> newEx.args\n\n3-element Array{Any,1}:\n :/\n :y\n :z","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"Since none of these arguments is another expression, newEx will be passed to latexoperation(). This function checks which mathematical operation is being done and converts newEx to an appropriately formatted string. In this case, that string will be \"\\\\frac{y}{z}\" (and yes, a double slash is needed).","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"newEx is now a string (despite its name):","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"julia> newEx\n\n\"\\\\frac{y}{z}\"","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"The recursive latexraw() pulls this value back to the original expression ex, such that:","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"julia> ex.args\n\n3-element Array{Any,1}:\n :+      \n :x      \n :\"\\\\frac{y}{z}\"","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"Now, since this expression does not consist of any further expressions, it is passed to latexoperation(). The operator is now \"+\", and it should be applied on the second and third element of the expression, resulting in:","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"\"x + \\\\frac{y}{z}\"","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"using the print function you get:","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"julia> print(latexraw(ex))\n\n\"x + \\frac{y}{z}\"","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"which in a LaTeX maths environment renders as:","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"x + fracyz","category":"page"},{"location":"tutorials/inner_workings/#Extended-functionality-1","page":"Inner workings","title":"Extended functionality","text":"","category":"section"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"With the above example we can understand how an expression is converted to a LaTeX formatted string (unless my pedagogical skills are worse than I fear).","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"So, anything which can be converted to a Julia expression of the Expr type can be latexified. Luckily, since Julia needs to convert your code to expressions before it can be evaluated, Julia is already great at doing this.","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"There are already some methods for converting other types to expressions and passing them to the core method, for example:","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"latexraw(str::String) = latexraw(parse(str))","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"but if you find yourself wanting to parse some other type, it is often easy to overload the latexraw function.","category":"page"},{"location":"tutorials/inner_workings/#Latexifying-Arrays-1","page":"Inner workings","title":"Latexifying Arrays","text":"","category":"section"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"Also, if you pass an array to latexraw, it will recursively try to convert the elements of that array to LaTeX formatted strings.","category":"page"},{"location":"tutorials/inner_workings/#","page":"Inner workings","title":"Inner workings","text":"julia> arr = [:(x-y/(k_10+z)), \"x*y*z/3\"]\njulia> latexraw(arr)\n2-element Array{String,1}:\n \"x - \\\\frac{y}{k_{10} + z}\"     \n \"\\\\frac{x \\\\cdot y \\\\cdot z}{3}\"\n\njulia> println.(latexraw(arr))\nx - \\frac{y}{k_{10} + z}\n\\frac{x \\cdot y \\cdot z}{3}","category":"page"}]
}
