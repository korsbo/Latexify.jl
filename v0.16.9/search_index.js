var documenterSearchIndex = {"docs":
[{"location":"functions/latexarray/#latexarray","page":"latexarray","title":"latexarray","text":"","category":"section"},{"location":"functions/latexarray/#Latexify.latexarray","page":"latexarray","title":"Latexify.latexarray","text":"latexarray{T}(arr::AbstractArray{T, 2})\n\nCreate a LaTeX array environment using latexraw.\n\nExamples\n\narr = [1 2; 3 4]\nlatexarray(arr)\n\nbeginequation\nleft\nbeginarraycc\n1  2 \n3  4 \nendarray\nright\nendequation\n\n\n\n\n\n\n","category":"function"},{"location":"functions/latexraw/#latexraw","page":"latexraw","title":"latexraw","text":"","category":"section"},{"location":"functions/latexraw/","page":"latexraw","title":"latexraw","text":"Formats the input for LaTeX without surrounding it with an environment.","category":"page"},{"location":"functions/latexraw/#Latexify.latexraw","page":"latexraw","title":"Latexify.latexraw","text":"latexraw(arg)\n\nGenerate LaTeX equations from arg.\n\nParses expressions, ParameterizedFunctions, SymEngine.Base and arrays thereof. Returns a string formatted for LaTeX.\n\nExamples\n\nusing expressions\n\nexpr = :(x/(y+x))\nlatexraw(expr)\n\n# output\n\n\"\\\\frac{x}{y + x}\"\n\nexpr = Meta.parse(\"x/(y+x)\")\nlatexraw(expr)\n\n# output\n\n\"\\\\frac{x}{y + x}\"\n\nusing ParameterizedFunctions\n\nusing DifferentialEquations;\nf = @ode_def feedback begin\n         dx = y/c_1 - x\n         dy = x^c_2 - y\n       end c_1=>1.0 c_2=>1.0\nlatexraw(f)\n\n# output\n\n2-element Array{String,1}:\n \"dx/dt = \\\\frac{y}{c_{1}} - x\"\n \"dy/dt = x^{c_{2}} - y\"\n\nusing SymEngine\n\nusing SymEngine\n@vars x y\nsymExpr = x + x + x*y*y\nlatexraw(symExpr)\n\n# output\n\n\"2 \\\\cdot x + x \\\\cdot y^{2}\"\n\n\n\n\n\n","category":"function"},{"location":"tutorials/latexinline/#latexinline","page":"latexinline","title":"latexinline","text":"","category":"section"},{"location":"tutorials/latexinline/","page":"latexinline","title":"latexinline","text":"takes a Julia object x and returns a LaTeX formatted string. It also surrounds the output in a simple $$ environment. This works for x of many types, including expressions, which returns LaTeX code for an equation.","category":"page"},{"location":"tutorials/latexinline/","page":"latexinline","title":"latexinline","text":"julia> ex = :(x-y/z)\njulia> latexinline(ex)\nL\"$x - \\frac{y}{z}$\"","category":"page"},{"location":"tutorials/latexinline/","page":"latexinline","title":"latexinline","text":"In Jupyter or Hydrogen this automatically renders as:","category":"page"},{"location":"tutorials/latexinline/","page":"latexinline","title":"latexinline","text":"x - fracyz","category":"page"},{"location":"tutorials/latexinline/","page":"latexinline","title":"latexinline","text":"Among the supported types are:","category":"page"},{"location":"tutorials/latexinline/","page":"latexinline","title":"latexinline","text":"Expressions,\nStrings,\nNumbers (including rational and complex),\nSymbols,\nSymbolic expressions from SymEngine.jl.\nParameterizedFunctions.","category":"page"},{"location":"tutorials/latexinline/","page":"latexinline","title":"latexinline","text":"It can also take arrays, which it recurses and latexifies the elements, returning an array of latex strings.","category":"page"},{"location":"tutorials/latexarray/#latexarray","page":"latexarray","title":"latexarray","text":"","category":"section"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"This functions takes a 1 or 2D array and spits out a latex array environment. For example:","category":"page"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"julia> arr = eye(Int,3)\njulia> print(latexarray(arr))\n\n\\begin{equation}\n\\left[\n\\begin{array}{ccc}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\\\\\n\\end{array}\n\\right]\n\\end{equation}","category":"page"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"which renders as:","category":"page"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"\\begin{equation} \\left[ \\begin{array}{ccc} 1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\\\\\n\\end{array} \\right] \\end{equation}","category":"page"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"latexraw() is called for each element of the input, individually. It therefore does not matter if the input array is of a mixed type.","category":"page"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"arr = [1.0, 2-3im, 3//4, :(x/(k_1+x)), \"e^(-k_b*t)\"]\nlatexarray(arr)","category":"page"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"renders as:","category":"page"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"\\begin{equation} \\left[ \\begin{array}{c} 1.0\\\\\n2-3\\textit{i}\\\\\n\\frac{3}{4}\\\\\n\\frac{x}{k{1} + x}\\\\\ne^{- k{b} \\cdot t}\\\\\n\\end{array} \\right] \\end{equation}","category":"page"},{"location":"tutorials/parameterizedfunctions/#Use-with-ParameterizedFunctions","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"","category":"section"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"In the latexalign tutorial I mentioned that one can use latexalign directly on a ParameterizedFunction. Here, I make a somewhat more convoluted and hard-to-read example (you'll soon se why):","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"using Latexify\nusing ParameterizedFunctions\ncopy_to_clipboard(true)\n\node = @ode_def positiveFeedback begin\n    dx = y*y*y/(k_y_x + y) - x - x\n    dy = x^n_x/(k_x^n_x + x^n_x) - y\nend k_y k_x n_x\n\nlatexify(ode)","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginalign\nfracdxdt = fracy cdot y cdot yk_y_x + y - x - x \nfracdydt = fracx^n_xk_x^n_x + x^n_x - y \nendalign","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"This is pretty nice, but there are a few parts of the equation which could be reduced. Using a keyword argument, you can utilise the SymEngine.jl to reduce the expression before printing.","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"latexify(ode, field=:symfuncs)","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginalign\nfracdxdt = -2 cdot x + fracy^3k_y_x + y \nfracdydt =  - y + fracx^n_xk_x^n_x + x^n_x \nendalign","category":"page"},{"location":"tutorials/parameterizedfunctions/#Side-by-side-rendering-of-multiple-system.","page":"Use with ParameterizedFunctions","title":"Side-by-side rendering of multiple system.","text":"","category":"section"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"A vector of ParameterizedFunctions will be rendered side-by-side:","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"ode2 = @ode_def negativeFeedback begin\n    dx = y/(k_y + y) - x\n    dy = k_x^n_x/(k_x^n_x + x^n_x) - y\nend k_y k_x n_x\n\nlatexify([ode, ode2])","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginalign\nfracdxdt  =  fracy cdot y cdot yk_y_x + y - x - x    fracdxdt  =  fracyk_y + y - x    \nfracdydt  =  fracx^n_xk_x^n_x + x^n_x - y    fracdydt  =  frack_x^n_xk_x^n_x + x^n_x - y    \nendalign","category":"page"},{"location":"tutorials/parameterizedfunctions/#Visualise-your-parameters.","page":"Use with ParameterizedFunctions","title":"Visualise your parameters.","text":"","category":"section"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"Another thing that I have found useful is to display the parameters of these functions. The parameters are usually in a vector, and if it is somewhat long, then it can be annoying to try to figure out which element belongs to which parameter. There are several ways to solve this. Here are two:","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"## lets say that we have some parameters\nparam = [3.4,5.2,1e-2]\nlatexify(ode.params, param)","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginalign\nk_y = 34 \nk_x = 52 \nn_x = 001 \nendalign","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"or","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"latexify([ode.params, param]; env=:array, transpose=true)","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginequation\nleft\nbeginarrayccc\nk_y  k_x  n_x \n34  52  001 \nendarray\nright\nendequation","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"signif.() is your friend if your parameters have more significant numbers than you want to see.","category":"page"},{"location":"tutorials/parameterizedfunctions/#Get-the-jacobian,-hessian,-etc.","page":"Use with ParameterizedFunctions","title":"Get the jacobian, hessian, etc.","text":"","category":"section"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"ParameterizedFunctions symbolically calculates the jacobian, inverse jacobian, hessian, and all kinds of goodness. Since they are available as arrays of symbolic expressions, which are latexifyable, you can render pretty much all of them.","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"latexify(ode.symjac)","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginequation\nleft\nbeginarraycc\n-2  frac3 cdot y^2k_y_x + y - fracy^3left( k_y_x + y right)^2 \nfracx^-1 + n_x cdot n_xk_x^n_x + x^n_x - fracx^-1 + 2 cdot n_x cdot n_xleft( k_x^n_x + x^n_x right)^2  -1 \nendarray\nright\nendequation","category":"page"},{"location":"tutorials/parameterizedfunctions/#Available-options","page":"Use with ParameterizedFunctions","title":"Available options","text":"","category":"section"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :ParameterizedFunction in arg.types || :Any in arg.types]\nlatexify(args, env=:mdtable, types=false)","category":"page"},{"location":"tutorials/rendering_latex/#A-note-on-rendering-\\LaTeX","page":"A note on rendering LaTeX","title":"A note on rendering LaTeX","text":"","category":"section"},{"location":"tutorials/rendering_latex/","page":"A note on rendering LaTeX","title":"A note on rendering LaTeX","text":"Using the print function on a latexified object prints text which is suitable for copy-pasting into a LaTeX document.","category":"page"},{"location":"tutorials/rendering_latex/","page":"A note on rendering LaTeX","title":"A note on rendering LaTeX","text":"However, it is often also useful to be able to render the equation inside the document that one is using to develop code. The Julia REPL does not support this, but IJulia does. So, inside a Jupyter or Pluto notebook (or if you are running Atom with Hydrogen), you can render LaTeX using","category":"page"},{"location":"tutorials/rendering_latex/","page":"A note on rendering LaTeX","title":"A note on rendering LaTeX","text":"display(\"text/latex\", x)","category":"page"},{"location":"tutorials/rendering_latex/","page":"A note on rendering LaTeX","title":"A note on rendering LaTeX","text":"where x is a latex-formatted string.","category":"page"},{"location":"tutorials/rendering_latex/","page":"A note on rendering LaTeX","title":"A note on rendering LaTeX","text":"This requires x to specify a LaTeX environment. latexalign and latexequation already does this, but if you want to render the result of latexify you must supply an environment (for example \"\\$ $x \\$\").","category":"page"},{"location":"tutorials/notebooks/#Notebook-workflows","page":"Notebook workflows","title":"Notebook workflows","text":"","category":"section"},{"location":"tutorials/notebooks/","page":"Notebook workflows","title":"Notebook workflows","text":"When working in a notebook (These tips assume Pluto, but will apply at least in part to other similar environments), there's a number of options to incorporate latexifications.","category":"page"},{"location":"tutorials/notebooks/","page":"Notebook workflows","title":"Notebook workflows","text":"As a first principle, any cell that returns a single LaTeXString (or a string surrounded by $ in general) will be displayed as math:","category":"page"},{"location":"tutorials/notebooks/","page":"Notebook workflows","title":"Notebook workflows","text":"latexify(35e-9; fmt=FancyNumberFormatter())","category":"page"},{"location":"tutorials/notebooks/","page":"Notebook workflows","title":"Notebook workflows","text":"35 cdot 10^-8","category":"page"},{"location":"tutorials/notebooks/","page":"Notebook workflows","title":"Notebook workflows","text":"@latexify (3x + 45)/2y","category":"page"},{"location":"tutorials/notebooks/","page":"Notebook workflows","title":"Notebook workflows","text":"frac3 cdot x + 452 cdot y","category":"page"},{"location":"tutorials/notebooks/","page":"Notebook workflows","title":"Notebook workflows","text":"There's a visual bug in Pluto where any expression looking like an assignment is printed with extra unnecessary information. To avoid this, encase such in a begin/end block:","category":"page"},{"location":"tutorials/notebooks/","page":"Notebook workflows","title":"Notebook workflows","text":"begin\n    @latexrun x = 125\nend","category":"page"},{"location":"tutorials/notebooks/","page":"Notebook workflows","title":"Notebook workflows","text":"x = 125","category":"page"},{"location":"tutorials/notebooks/","page":"Notebook workflows","title":"Notebook workflows","text":"begin\n    @latexdefine y = x\nend","category":"page"},{"location":"tutorials/notebooks/","page":"Notebook workflows","title":"Notebook workflows","text":"y = x = 125","category":"page"},{"location":"tutorials/notebooks/","page":"Notebook workflows","title":"Notebook workflows","text":"One very nice workflow is to use Markdown.parse to embed latexifications in markdown text. Note that md\"\" does not work very well for this, as the dollar signs signifying math mode will clash with those signifying interpolation. In parse, you need to escape special characters like backslashes, but since we're using Latexify we don't need to write very many of those anyway.","category":"page"},{"location":"tutorials/notebooks/","page":"Notebook workflows","title":"Notebook workflows","text":"Markdown.parse(\"\"\"\n## Results\n\nWith the previously calculated \n$(@latexdefine x), we can use\n$(@latexify x = v*t) to calculate\n$(@latexrun v = x/10), giving a final\nvelocity of $(latexify(v)).\n\nIf we want more manual control, we can\ncombine manual dollar signs with\n`env=:raw`: \\$ \\hat{v} =\n$(latexify(v, env=:raw))\\;\\mathrm{m}/\\mathrm{s} \\$\n\"\"\")","category":"page"},{"location":"tutorials/notebooks/#Results","page":"Notebook workflows","title":"Results","text":"","category":"section"},{"location":"tutorials/notebooks/","page":"Notebook workflows","title":"Notebook workflows","text":"With the previously calculated  x = 125, we can use x = v cdot t to calculate v = fracx10, giving a final velocity of 125.","category":"page"},{"location":"tutorials/notebooks/","page":"Notebook workflows","title":"Notebook workflows","text":"If we want more manual control, we can combine manual dollar signs with env=:raw: $ \\hat{v} = 12.5\\;\\mathrm{m}/\\mathrm{s} $","category":"page"},{"location":"tutorials/latexalign/#latexalign_tutorial","page":"latexalign","title":"latexalign","text":"","category":"section"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"This function converts its input to LaTeX align environments. One way of using the function is to pass it two vectors, one which holds the left-hand-side of the equations and the other which holds the right. For example:","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"lhs = [\"dx/dt\", \"dy/dt\"]\nrhs = [\"y^2 - x\", \"x/y - y\"]\nprint(latexalign(lhs, rhs))","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"outputs:","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"\\begin{align}\n\\frac{dx}{dt} &= y^{2} - x \\\\\n\\frac{dy}{dt} &= \\frac{x}{y} - y \\\\\n\\end{align}","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"In Jupyter, this can be rendered by:","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"display( latexalign(lhs, rhs))","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"\\begin{align*} \\frac{dx}{dt} &= y^{2} - x \\\\\n\\frac{dy}{dt} &= \\frac{x}{y} - y \\\\\n\\end{align*}","category":"page"},{"location":"tutorials/latexalign/#Using-DifferentialEquations.jl","page":"latexalign","title":"Using DifferentialEquations.jl","text":"","category":"section"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"The motivation for creating this function was mainly to be able to render ODEs. In my own work, I tend to use DifferentialEquations.jl to define ODEs as ParameterizedFunctions. Therefore, I found it useful to create a method which simply takes the ParameterizedFunction as input:","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"using Latexify\nusing DifferentialEquations\node = @ode_def positiveFeedback begin\n    dx = y/(k_y + y) - x\n    dy = x^n_x/(k_x^n_x + x^n_x) - y\nend k_y k_x n_x\n\nlatexalign(ode)","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"\\begin{align} \\frac{dx}{dt} &= \\frac{y}{k{y} + y} - x \\\\\n\\frac{dy}{dt} &= \\frac{x^{n{x}}}{k{x}^{n{x}} + x^{n_{x}}} - y \\\\\n\\end{align}","category":"page"},{"location":"tutorials/inner_workings/#Inner-workings","page":"Inner workings","title":"Inner workings","text":"","category":"section"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"This package contains a large number of methods, but two of these are of special importance. These are:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"latexraw(ex::Expr)","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"and","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"latexoperation(ex::Expr, prevOp::AbstractArray)","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"These two methods are involved with all conversions to LaTeX equations. ","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"latexraw(ex::Expr) utilises Julias homoiconicity to infer the correct latexification of an expression by recursing through the expression tree. Whenever it hits the end of a recursion it passes the last expression to latexoperation(). By the nature of this recursion, this expression is one which only contains symbols or strings.","category":"page"},{"location":"tutorials/inner_workings/#Explanation-by-example","page":"Inner workings","title":"Explanation by example","text":"","category":"section"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"Let's define a variable of the expression type:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> ex = :(x + y/z)","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"This expression has a field which contains the first operation which must be done, along with the objects that this operation will operate on:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> ex.args\n\n3-element Array{Any,1}:\n :+      \n :x      \n :(y / z)","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"The first two element are both Symbols, while the third one is an expression:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> typeof.(ex.args)\n\n3-element Array{DataType,1}:\n Symbol\n Symbol\n Expr","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"Since at least one of these elements is an expression, the next step of the recursive algorithm is to dive into that expression:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> newEX = ex.args[3]\njulia> newEx.args\n\n3-element Array{Any,1}:\n :/\n :y\n :z","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"Since none of these arguments is another expression, newEx will be passed to latexoperation(). This function checks which mathematical operation is being done and converts newEx to an appropriately formatted string. In this case, that string will be \"\\\\frac{y}{z}\" (and yes, a double slash is needed).","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"newEx is now a string (despite its name):","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> newEx\n\n\"\\\\frac{y}{z}\"","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"The recursive latexraw() pulls this value back to the original expression ex, such that:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> ex.args\n\n3-element Array{Any,1}:\n :+      \n :x      \n :\"\\\\frac{y}{z}\"","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"Now, since this expression does not consist of any further expressions, it is passed to latexoperation(). The operator is now \"+\", and it should be applied on the second and third element of the expression, resulting in:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"\"x + \\\\frac{y}{z}\"","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"using the print function you get:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> print(latexraw(ex))\n\n\"x + \\frac{y}{z}\"","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"which in a LaTeX maths environment renders as:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"x + fracyz","category":"page"},{"location":"tutorials/inner_workings/#Extended-functionality","page":"Inner workings","title":"Extended functionality","text":"","category":"section"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"With the above example we can understand how an expression is converted to a LaTeX formatted string (unless my pedagogical skills are worse than I fear).","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"So, anything which can be converted to a Julia expression of the Expr type can be latexified. Luckily, since Julia needs to convert your code to expressions before it can be evaluated, Julia is already great at doing this.","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"There are already some methods for converting other types to expressions and passing them to the core method, for example:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"latexraw(str::String) = latexraw(parse(str))","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"but if you find yourself wanting to parse some other type, it is often easy to overload the latexraw function.","category":"page"},{"location":"tutorials/inner_workings/#Latexifying-Arrays","page":"Inner workings","title":"Latexifying Arrays","text":"","category":"section"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"Also, if you pass an array to latexraw, it will recursively try to convert the elements of that array to LaTeX formatted strings.","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> arr = [:(x-y/(k_10+z)), \"x*y*z/3\"]\njulia> latexraw(arr)\n2-element Array{String,1}:\n \"x - \\\\frac{y}{k_{10} + z}\"     \n \"\\\\frac{x \\\\cdot y \\\\cdot z}{3}\"\n\njulia> println.(latexraw(arr))\nx - \\frac{y}{k_{10} + z}\n\\frac{x \\cdot y \\cdot z}{3}","category":"page"},{"location":"functions/latexoperation/#latexoperation","page":"latexoperation","title":"latexoperation","text":"","category":"section"},{"location":"functions/latexoperation/","page":"latexoperation","title":"latexoperation","text":"This function is not exported.","category":"page"},{"location":"functions/latexoperation/#Latexify.latexoperation","page":"latexoperation","title":"Latexify.latexoperation","text":"latexoperation(ex::Expr, prevOp::AbstractArray)\n\nTranslate a simple operation given by ex to LaTeX maths syntax. This uses the information about the previous operations to decide if a parenthesis is needed.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/Catalyst/#Use-with-@reaction_network-from-Catalyst.jl.","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"","category":"section"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"Latexify.jl has methods for dealing with the ReactionNetwork models generated by Catalyst.jl. More information regarding these can be found here. The latexify end of things are pretty simple: feed a reaction network to latexify() and let it do its magic.","category":"page"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"using Catalyst\nusing Latexify\ncopy_to_clipboard(true)\n\nhill2(x, v, k) = v*x^2/(k^2 + x^2)\nrn = @reaction_network begin\n  hill2(y, v_x, k_x), 0 --> x\n  p_y, 0 --> y\n  (d_x, d_y), (x, y) --> 0\n  (r_b, r_u), x ↔ y\nend\n\nlatexify(rn; form=:ode)","category":"page"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"beginalign\nfracdxdt = fracv_x cdot y^2k_x^2 + y^2 - d_x cdot x - r_b cdot x + r_u cdot y \nfracdydt = p_y - d_y cdot y + r_b cdot x - r_u cdot y \nendalign","category":"page"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"Alternatively, the SDEs generated through the chemical Langevin equations can be displayed by setting the form argument to :sde. Here, the noise in the reaction network is correlated/","category":"page"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"latexify(rn; form=:sde)","category":"page"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"beginalign\nfracdxdt = sqrtfracv_x cdot y^2k_x^2 + y^2 - sqrtd_x cdot x - sqrtr_b cdot x + sqrtr_u cdot y \nfracdydt = sqrtp_y - sqrtd_y cdot y + sqrtr_b cdot x - sqrtr_u cdot y \nendalign","category":"page"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"Note: On the current version of Latexify, generation of SDEs from reaction networks is broken.","category":"page"},{"location":"tutorials/Catalyst/#Chemical-arrow-notation","page":"Use with @reaction_network from Catalyst.jl.","title":"Chemical arrow notation","text":"","category":"section"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"Catalyst reaction network is all about chemical arrow notation, so why should we not be able to render arrows?","category":"page"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"This is the default output (when no value to form is given).","category":"page"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"latexify(rn; env=:chemical)","category":"page"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"\\begin{align} \\require{mhchem} \\ce{ \\varnothing &->[\\frac{v{x} \\cdot y^{2}}{k{x}^{2} + y^{2}}] x}\\\\\n\\ce{ \\varnothing &->[p{y}] y}\\\\\n\\ce{ x &->[d{x}] \\varnothing}\\\\\n\\ce{ y &->[d{y}] \\varnothing}\\\\\n\\ce{ x &<=>[{r{b}}][{r_{u}}] y}\\\\\n\\end{align}","category":"page"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"The default output is meant to be rendered directly on the screen. This rendering is typically done by MathJax. To get the chemical arrow notation to render automatically, I have included a MathJax command (\\require{mhchem}) in the output string. If you want to use the output in a real LaTeX document, you can pass the keyword argument mathjax=false and this extra command will be omitted. In such case you should also add \\usepackage{mhchem} to the preamble of your latex document.","category":"page"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"Another keyword argument that may be of use is expand=false (defaults to true). This determines whether your functions should be expanded or not. Also, starred=true will change the outputted latex environment from align to align*. This results in the equations not being numbered.","category":"page"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"latexify(rn; env=:chemical, expand=false, starred=true)","category":"page"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"beginalign*\nrequiremhchem\nce varnothing -mathrmhill2left( y v_x k_x right) x\nce varnothing -p_y y\nce x -d_x varnothing\nce y -d_y varnothing\nce x =r_br_u y\nendalign*","category":"page"},{"location":"tutorials/Catalyst/#Available-options","page":"Use with @reaction_network from Catalyst.jl.","title":"Available options","text":"","category":"section"},{"location":"tutorials/Catalyst/#Align","page":"Use with @reaction_network from Catalyst.jl.","title":"Align","text":"","category":"section"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if (:ReactionNetwork in arg.types || :Any in arg.types) && :align in arg.env]\nlatexify(args, env=:mdtable, types=false)","category":"page"},{"location":"tutorials/Catalyst/#Arrow-notation","page":"Use with @reaction_network from Catalyst.jl.","title":"Arrow notation","text":"","category":"section"},{"location":"tutorials/Catalyst/","page":"Use with @reaction_network from Catalyst.jl.","title":"Use with @reaction_network from Catalyst.jl.","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if (:ReactionNetwork in arg.types || :Any in arg.types) && :arrow in arg.env]\nlatexify(args, env=:mdtable, types=false)","category":"page"},{"location":"tutorials/latexify/#latexify","page":"latexify","title":"latexify","text":"","category":"section"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"This is a wrapper of some of the other latexXXX functions. It tries to infer a suitable output mode for the given input. If the environment you are using supports the MIME type \"text/latex\", then the output will be rendered nicely.","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"using Latexify\ncopy_to_clipboard(true)\n\nex = :(x/y)\nlatexify(ex)\n","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"fracxy","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"If you print the output rather than display, then you will enforce the print-out of a string which is ready for some copy-pasting into your LaTeX document.","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"println(latexify(ex))\n\n## or the equivalent:\nlatexify(ex) |> println","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"$\\frac{x}{y}$","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"A matrix, or a single vector, is turned into an array.","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"M = signif.(rand(3,4), 2)\n\nlatexify(M)","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"\\begin{equation} \\left[ \\begin{array}{cccc} 0.85 & 0.99 & 0.85 & 0.5\\\\\n0.59 & 0.061 & 0.77 & 0.48\\\\\n0.7 & 0.17 & 0.7 & 0.82\\\\\n\\end{array} \\right] \\end{equation}","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"You can transpose the output using the keyword argument transpose=true.","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"If you give two vectors as an argument, they will be displayed as the left-hand-side and right-hand-side of an align environment:","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"latexify([\"x/y\", :z], Any[2.3, 1//2])","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"\\begin{align} \\frac{x}{y} &= 2.3 \\\\\nz &= \\frac{1}{2} \\\\\n\\end{align}","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"If you input a ParameterizedFunction or a ReactionNetwork from DifferentialEquations.jl you will also get an align environment. For more on this, have a look on their respective sections.","category":"page"},{"location":"tutorials/recipes/#Recipes","page":"Recipes","title":"Recipes","text":"","category":"section"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"Recipes provides a concise means of extending Latexify.jl to work with types of your own making or of other packages. The @latexrecipe macro allows you to specify how a an argument type (or a set of types) should be pre-processed before they are passed to the standard latexify function. Also, it allows you to define both new keyword arguments as well as to set the defaults of pre-existing ones. The main power of this macro is that is defines the necessary functions within Latexify.jl itself, as opposed to within the module where it is called. ","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"The recipe syntax closely follow that of the Plots.jl recipes and, indeed, most of the code is copied and adapted from them (cred to the authors!). ","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"So. The easiest way to explain it is by showing an example where we define a recipe for our type MyType. ","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"using Latexify\n\nstruct MyType \n   vector::Vector\nend","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"@latexrecipe function f(x::MyType; reverse=false)\n    ## we can access the input object and perform operations like in a normal function.\n    vec = x.vector\n    if reverse\n        vec = vec[end:-1:1]\n    end\n\n    ## we can define defult keyword arguments to be passed along to latexify \n    ## using an arrow notation, --> \n    env --> :array\n    transpose --> true\n    ## These can be overridden by the keyword arguments passed to the latexify function.\n\n    ## If you use the := operator to specify a value it cannot be overridden.\n    fmt := \"%.2f\"\n\n    ## The return value should be something that latexify already knows how to work with.\n    ## In this case, we have a simple vector which is fine!\n    return vec\nend","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"mytype = MyType([1, 2, 3])\n\nlatexify(mytype; reverse=true)","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"beginequation\nleft\nbeginarrayc\n300 \n200 \n100 \nendarray\nright\nendequation","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"The required signature of the macro is","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"@latexrecipe function f(x::MyType, ...; ...)\n    return something\nend","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"Here, the function name is unimportant, but the type signature is key.  There must also be an explicit return statement which returns something that  base Latexify already works with (Arrays, Tuples, Numbers, Symbols, Strings, etc.). In particular, you can not rely on Julia's default to return the value of the  last expression evaluated in a function body.","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"The special notation kwarg --> value resets the default value of a keyword argument for your specific inputs. This will be overridden if the keyword argument in quesion is specified in a call to latexify.  To disallow this overriding, use kwarg := value instead.","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"The use of @latexrecipe to redefine how an already supported type should be interpreted is highly discouraged. There is (currently) nothing in place to forbid this but it could mess up how latexify works with other packages. Disregarding this in your own sessions is one thing, but doing it in a package could cause very difficult issues for the users of your package. ","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"If a recipe is defined within a module, everything should just work without the need to export anything. ","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"The special keyword argument operation lets you specify that a type corresponds to a specific arithmetic operation. For instance, if we define a type ","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"struct MyDifference\nx\ny\nend","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"that is meant to represent the operation x - y, we might want to create the recipe","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"@latexrecipe function f(m::MyDifference)\n    return :($(m.y) - $(m.x))\nend","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"so that the result of latexify(MyDifference(2,3)) is 3 - 2. But right now, latexify does not know that this represents an operation, so for instance @latexify $(MyDifference(2,3))*4 gives 3 - 2 cdot 4, which is incorrect. The way around this is to edit the recipe:","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"@latexrecipe function f(m::MyDifference)\n    operation := :-\n    return :($(m.y) - $(m.x))\nend","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"Now latexify knows that MyDifference represents a subtraction, and parenthesis rules kick in: @latexify $(MyDifference(2,3))*4 gives left( 3 - 2 right) cdot 4.","category":"page"},{"location":"tutorials/latextabular/#latextabular","page":"latextabular","title":"latextabular","text":"","category":"section"},{"location":"tutorials/latextabular/","page":"latextabular","title":"latextabular","text":"using Latexify\ncopy_to_clipboard(true)\narr = [\"x/y\" :(y^n); 1.0 :(alpha(x))]\nlatextabular(arr) |> println","category":"page"},{"location":"tutorials/latextabular/","page":"latextabular","title":"latextabular","text":"outputs:","category":"page"},{"location":"tutorials/latextabular/","page":"latextabular","title":"latextabular","text":"\\begin{tabular}{cc}\n$\\frac{x}{y}$ & $y^{n}$\\\\\n$1.0$ & $\\alpha\\left( x \\right)$\\\\\n\\end{tabular}","category":"page"},{"location":"tutorials/latextabular/","page":"latextabular","title":"latextabular","text":"Unfortunately, this does not render nicely in Markdown. But you get the point.","category":"page"},{"location":"tutorials/latextabular/","page":"latextabular","title":"latextabular","text":"latextabular takes two keywords, one for changing the adjustment of the columns (centered by default), and one for transposing the whole thing.","category":"page"},{"location":"tutorials/latextabular/","page":"latextabular","title":"latextabular","text":"latextabular(arr; adjustment=:l, transpose=true) |> println","category":"page"},{"location":"tutorials/latextabular/","page":"latextabular","title":"latextabular","text":"\\begin{tabular}{ll}\n$\\frac{x}{y}$ & $1.0$\\\\\n$y^{n}$ & $\\alpha\\left( x \\right)$\\\\\n\\end{tabular}","category":"page"},{"location":"tutorials/latextabular/","page":"latextabular","title":"latextabular","text":"The adjustments can be set per column by providing a vector like [:c, :l, :r]. If you want to use the S column type from siunitx, set latex=false, adjustment=:S. Some post-adjustment may be necessary.","category":"page"},{"location":"functions/latexalign/#latexalign","page":"latexalign","title":"latexalign","text":"","category":"section"},{"location":"functions/latexalign/#Latexify.latexalign","page":"latexalign","title":"Latexify.latexalign","text":"latexalign()\n\nGenerate a LaTeX align environment from an input.\n\nExamples\n\nuse with arrays\n\nlhs = [:(dx/dt), :(dy/dt), :(dz/dt)]\nrhs = [:(y-x), :(x*z-y), :(-z)]\nlatexalign(lhs, rhs)\n\n\\begin{align}\n\\frac{dx}{dt} &= y - x \\\\\\\\\n\\frac{dy}{dt} &= x \\cdot z - y \\\\\\\\\n\\frac{dz}{dt} &= - z \\\\\\\\\n\\end{align}\n\nuse with ParameterizedFunction\n\njulia> using DifferentialEquations\njulia> ode = @ode_def foldChangeDetection begin\n    dm = r_m * (i - m)\n    dy = r_y * (p_y * i/m - y)\nend i r_m r_y p_y\n\njulia> latexalign(ode)\n\n\\begin{align}\n\\frac{dm}{dt} &= r_{m} \\cdot \\left( i - m \\right) \\\\\\\\\n\\frac{dy}{dt} &= r_{y} \\cdot \\left( \\frac{p_{y} \\cdot i}{m} - y \\right) \\\\\\\\\n\\end{align}\n\n\n\n\n\n","category":"function"},{"location":"arguments/#List-of-possible-arguments","page":"List of possible arguments","title":"List of possible arguments","text":"","category":"section"},{"location":"arguments/#Align","page":"List of possible arguments","title":"Align","text":"","category":"section"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :align in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Equation","page":"List of possible arguments","title":"Equation","text":"","category":"section"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :equation in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Array","page":"List of possible arguments","title":"Array","text":"","category":"section"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :array in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Tabular","page":"List of possible arguments","title":"Tabular","text":"","category":"section"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :tabular in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Markdown-Table","page":"List of possible arguments","title":"Markdown Table","text":"","category":"section"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :mdtable in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Inline-and-raw","page":"List of possible arguments","title":"Inline and raw","text":"","category":"section"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :raw in arg.env || :inline in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Chemical-arrow-notation","page":"List of possible arguments","title":"Chemical arrow notation","text":"","category":"section"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Available with ReactionNetworks from Catalyst.","category":"page"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :arrow in arg.env]\nlatexify(args, env=:mdtable, types=false)","category":"page"},{"location":"#Latexify.jl","page":"Latexify.jl","title":"Latexify.jl","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Latexify.jl is a package which supplies functions for producing LaTeX  formatted strings from Julia objects. The package allows for latexification of a many different kinds of Julia object and it can output several different LaTeX or Markdown environments.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"A small teaser:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"using Latexify\ncopy_to_clipboard(false) # hide\nLatexify.set_default(; starred=true)\nm = [2//3 \"e^(-c*t)\" 1+3im; :(x/(x+k_1)) \"gamma(n)\" :(log10(x))]\nlatexify(m)","category":"page"},{"location":"#Supported-input","page":"Latexify.jl","title":"Supported input","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"This package supplies functionality for latexifying objects of the following types:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Expressions,\nStrings,\nNumbers (including rational and complex),\nMissing,\nSymbols,\nSymbolic expressions from SymEngine.jl,\nDataFrame from DataFrames.jl,\nAny shape of array containing a mix of any of the above types,\nParameterizedFunctions from DifferentialEquations.jl,\nReactionNetworks from DifferentialEquations.jl","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Example:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"str = \"x/(2*k_1+x^2)\"\nlatexify(str)","category":"page"},{"location":"#Supported-output","page":"Latexify.jl","title":"Supported output","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Latexify has support for generating a range of different LaTeX environments. The main function of the package, latexify(), automatically picks a suitable output environment based on the type(s) of the input. However, you can override this by passing the keyword argument env =. The following environments are available:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"environment env= description\nno env :raw Latexifies an object and returns a LaTeX formatted string. If the input is an array it will be recursed and all its elements latexified. This function does not surround the resulting string in any LaTeX environments.\nInline :inline latexify the input and surround it with $ for inline rendering.\nAlign :align Latexifies input and surrounds it with an align environment. Useful for systems of equations and such fun stuff.\nEquation :equation or :eq Latexifies input and surrounds it with an equation environment.\nArray :array Latexify the elements of an Array or a Dict and output them in a LaTeX array.\nTabular :table or :tabular Latexify the elements of an array and output a tabular environment. Note that tabular is not supported by MathJax and will therefore not be rendered in Jupyter, etc.\nMarkdown Table :mdtable Output a Markdown table. This will be rendered nicely by Jupyter, etc.\nMarkdown Text :mdtext Output and render any string which can be parsed into Markdown. This is really nothing but a call to Base.Markdown.parse(),  but it does the trick. Useful for rendering bullet lists and such things.\nChemical arrow notation :chem, :chemical, :arrow or :arrows Latexify an AbstractReactionNetwork to LaTeX formatted chemical arrow notation using mhchem.","category":"page"},{"location":"#Modifying-the-output","page":"Latexify.jl","title":"Modifying the output","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Some of the different outputs can be modified using keyword arguments. You can for example transpose an array with transpose=true or specify a header of a table or mdtable with header=[]. For more options, see the List of possible arguments.","category":"page"},{"location":"#Printing-vs-displaying","page":"Latexify.jl","title":"Printing vs displaying","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify() returns a LaTeXString. Using display() on such a string will try to render it.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(\"x/y\") |> display","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"fracxy","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Using print() will output text which is formatted for latex.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(\"x/y\") |> print","category":"page"},{"location":"#Number-formatting","page":"Latexify.jl","title":"Number formatting","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"You can control the formatting of numbers by passing any of the following to the fmt keyword:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"a printf-style formatting string, for example fmt = \"%.2e\".\na single argument function, for example fmt = x -> round(x, sigdigits=2).\na formatter supplied by Latexify.jl, for example fmt = FancyNumberFormatter(2) (thanks to @simeonschaub). You can pass any of these formatters an integer argument which specifies how many significant digits you want.\nFancyNumberFormatter() replaces the exponent notation, from 1.2e+3 to 1.2 \\cdot 10^3. \nStyledNumberFormatter() replaces the exponent notation, from 1.2e+3 to 1.2 \\mathrm{e} 3.\nSiunitxNumberFormatter() uses the siunitx package's \\num, so all the formatting is offloaded on the \\LaTeX engine. Formatting arguments can be supplied as a string to the keyword argument format_options. If your siunitx installation is version 2 or older, use the keyword argument version=2 to replace \\num by \\si. A boolean argument simple can be used to control syntax for units. These two latter options do not change output for unitless numbers.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Examples:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(12345.678; fmt=\"%.1e\")","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify([12893.1 1.328e2; \"x/y\" 7832//2378]; fmt=FancyNumberFormatter(3))","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"beginequation\nleft\nbeginarraycc\n129 cdot 10^4  133 \nfracxy  frac39161189 \nendarray\nright\nendequation","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"using Format\nlatexify([12893.1 1.328e2]; fmt=x->format(round(x, sigdigits=2), autoscale=:metric))","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"str = latexify(12345.678; fmt=SiunitxNumberFormatter(format_options=\"round-mode=places,round-precision=1\", version=3))\nreplace(string(str), \"\\$\"=>\"`\") # hide","category":"page"},{"location":"#Automatic-copying-to-clipboard","page":"Latexify.jl","title":"Automatic copying to clipboard","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"The strings that you would see when using print on any of the above functions can be automatically copied to the clipboard if you so specify. Since I do not wish to mess with your clipboard without you knowing it, this feature must be activated by you.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"To do so, run","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"copy_to_clipboard(true)","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"To once again disable the feature, pass false to the same function.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"The copying to the clipboard will now occur at every call to a Latexify.jl function, regardless of how you chose to display the output.","category":"page"},{"location":"#Automatic-displaying-of-result","page":"Latexify.jl","title":"Automatic displaying of result","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"You can toggle whether the result should be automatically displayed. Instead of","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(\"x/y\") |> display\n## or\ndisplay( latexify(\"x/y\") )","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"one can toggle automatic display by:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"auto_display(true)","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"after which all calls to latexify will automatically be displayed. This can be rather convenient, but it can also cause a lot of unwanted printouts if you are using latexify in any form of loop. You can turn off this behaviour again by passing false to the same function.","category":"page"},{"location":"#Setting-your-own-defaults","page":"Latexify.jl","title":"Setting your own defaults","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"If you get tired of specifying the same keyword argument over and over in a session, you can just reset its default:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"set_default(fmt = \"%.2f\", convert_unicode = false)","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Note that this changes Latexify.jl from within and should therefore only be used in your own Julia sessions (do not call this from within your packages). ","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"The calls are additive so that a new call with ","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"set_default(mult_symbol = \"\")","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"will not cancel out the changes we just made to fmt and convert_unicode. ","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"To view your changes, use","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"get_default()","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"and to reset your changes, use","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"reset_default()","category":"page"},{"location":"#Macros","page":"Latexify.jl","title":"Macros","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Three macros are exported. ","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"@latexify simply latexifies the expression that you provide to it, similar to latexify(:(...)).\n@latexrun both executes and latexifies the given expression. \n@latexdefine executes the expression, and latexifies the expression together with the its value","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"They can for example be useful for latexifying simple mathsy functions like","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"julia> lstr = @latexrun f(x; y=2) = x/y\nL\"$f\\left( x; y = 2 \\right) = \\frac{x}{y}$\"\n\njulia> f(1)\n0.5","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"julia> @latexdefine x = 1/2\nL\"$x = \\frac{1}{2} = 0.5\n\njulia> x\n0.5","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"The arguments to the macro can be interpolated with $ to use the actual value, instead of the representation:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"julia> @latexify x = abs2(-3)\nL\"$x = \\left|-3\\right|^{2}$\"\n\njulia> @latexify x = $(abs2(-3))\nL\"$x = 9$\"","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Keyword arguments can be supplied after these macros:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"julia> @latexdefine x env=:equation\nL\"\\begin{equation}\nx = 0.5\n\\end{equation}\n\"","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"A special keyword post can be supplied to @latexdefine, which is a function that will be called on the final right hand sign before latexification. This is merely formatting and will not affect any assignments.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"julia> @latexdefine x=π  post=round\nL\"$x = \\pi = 3.0$\"\n\njulia> @latexdefine x\nL\"$x = \\pi$\"","category":"page"},{"location":"#External-rendering","page":"Latexify.jl","title":"External rendering","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"While LaTeXStrings already render nicely in many IDEs or in Jupyter, they do not render in the REPL. Therefore, we provide a function render(str) which generates a standalone PDF using LuaLaTeX and opens that file in your default PDF viewer.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"I have found the following syntax pretty useful:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(:(x/y)) |> render","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Alternatively, render(str, mime) can also be used to generate and display DVI, PNG and SVG files, which might be useful for other purposes:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(:(x/y)) |> s -> render(s, MIME(\"image/png\"))","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"PNG output relies on ghostscript or alternatively on dvipng: if render is called with the keyword convert = :gs, ghostcript will be used to convert the pdf output to png format.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"SVG output relies on dvisvgm or alternatively on pdf2svg.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"If your code requires specific packages or document classes to render correctly, you can supply those as keyword arguments:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"L\"\\qty{1.25}{nm}\" |> render(s, MIME(\"image/png\"); documentclass=\"article\", packages=(\"microtype\", (\"siunitx\", exponent-product=\"\\cdot\")))","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"The arguments to these are either strings, or tuples of strings where the first one is the name of the package or class, and any further are optional arguments.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"One can use Latexify together with ImageInTerminal to render equations in a sixel compatible terminal, where the size of the sixel encoded image can be controlled using dpi:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"using ImageInTerminal, Latexify\n\nlatexify(:(iħ * (∂Ψ(𝐫, t) / ∂t) = -ħ^2 / 2m * ΔΨ(𝐫, t) + V * Ψ(𝐫, t))) |> s -> render(s, dpi=200)","category":"page"},{"location":"#Tectonic","page":"Latexify.jl","title":"Tectonic","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"The tectonic_jll package can be used as a lightweight compiler for CI and similar setups. An extension to Latexify makes render (to pdf) automatically use tectonic_jll if both packages are loaded. To still render using the default compiler, use render(...; use_tectonic=false).","category":"page"},{"location":"#Render-command-line-args","page":"Latexify.jl","title":"Render command-line args","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"For fine-tuning or setting other command-line arguments to a render pipeline, you can pass any of the following keyword arguments to render, some of which have default values.  Since these are interpolated into shell commands, note that you should surround with back-ticks \\` rather than quotes.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"lualatex_flags=`` (for default compilation to PDF)\ntectonic_flags=`` (for tectonic_jll compilation to PDF)\ndvilualatex_flags=`` (for compilation to DVI)\nghostscript_flags=`-sDEVICE=pngalpha -dTextAlphaBits=4 -r$dpi` (for generating PNG from PDF)\ndvipng_flags=`-bg Transparent -D $dpi -T tight` (for dvipng, for generating PNG from DVI)\npdf2svg_flags=`` (for generating SVG from PDF)\ndvisvgm_flags=`` (for generating SVG from DVI)\ndvilualatex_flags=`` (for generating DVI)","category":"page"},{"location":"#Legacy-support","page":"Latexify.jl","title":"Legacy support","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Latexify.jl has stopped supporting Julia versions older than 0.7. This does not mean that you cannot use Latexify with earlier versions, just that these will not get new features. Latexify.jl's release v0.4.1 was the last which supported Julia 0.6. Choose that release in the dropdown menu if you want to see that documentation.","category":"page"},{"location":"functions/latexify/#latexify","page":"latexify","title":"latexify","text":"","category":"section"},{"location":"functions/latexify/#Latexify.latexify","page":"latexify","title":"Latexify.latexify","text":"latexify(args...; kwargs...)\n\nLatexify a string, an expression, an array or other complex types.\n\njulia> latexify(\"x+y/(b-2)^2\")\nL\"$x + \\frac{y}{\\left( b - 2 \\right)^{2}}$\"\n\njulia> latexify(:(x/(y+x)^2))\nL\"$\\frac{x}{\\left( y + x \\right)^{2}}$\"\n\njulia> latexify([\"x/y\" 3//7 2+3im; 1 :P_x :(gamma(3))])\nL\"\\begin{equation}\n\\left[\n\\begin{array}{ccc}\n\\frac{x}{y} & \\frac{3}{7} & 2+3\\mathit{i} \\\\\n1 & P_{x} & \\Gamma\\left( 3 \\right) \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\"\n\n\n\n\n\n","category":"function"}]
}
