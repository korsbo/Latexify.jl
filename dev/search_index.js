var documenterSearchIndex = {"docs":
[{"location":"functions/latexarray/#latexarray","page":"latexarray","title":"latexarray","text":"","category":"section"},{"location":"functions/latexarray/","page":"latexarray","title":"latexarray","text":"DocTestSetup = quote\nusing Latexify\nusing DifferentialEquations\nend","category":"page"},{"location":"functions/latexarray/","page":"latexarray","title":"latexarray","text":"latexarray","category":"page"},{"location":"functions/latexarray/#Latexify.latexarray","page":"latexarray","title":"Latexify.latexarray","text":"latexarray{T}(arr::AbstractArray{T, 2})\n\nCreate a LaTeX array environment using latexraw.\n\nExamples\n\narr = [1 2; 3 4]\nlatexarray(arr)\n\nbeginequation\nleft\nbeginarraycc\n1  2 \n3  4 \nendarray\nright\nendequation\n\n\n\n\n\n\n","category":"function"},{"location":"functions/latexarray/","page":"latexarray","title":"latexarray","text":"DocTestSetup = nothing","category":"page"},{"location":"functions/latexraw/#latexraw","page":"latexraw","title":"latexraw","text":"","category":"section"},{"location":"functions/latexraw/","page":"latexraw","title":"latexraw","text":"Formats the input for LaTeX without surrounding it with an environment.","category":"page"},{"location":"functions/latexraw/","page":"latexraw","title":"latexraw","text":"latexalign","category":"page"},{"location":"tutorials/latexinline/#latexinline","page":"latexinline","title":"latexinline","text":"","category":"section"},{"location":"tutorials/latexinline/","page":"latexinline","title":"latexinline","text":"takes a Julia object x and returns a LaTeX formatted string. It also surrounds the output in a simple $$ environment. This works for x of many types, including expressions, which returns LaTeX code for an equation.","category":"page"},{"location":"tutorials/latexinline/","page":"latexinline","title":"latexinline","text":"julia> ex = :(x-y/z)\njulia> latexinline(ex)\nL\"$x - \\frac{y}{z}$\"","category":"page"},{"location":"tutorials/latexinline/","page":"latexinline","title":"latexinline","text":"In Jupyter or Hydrogen this automatically renders as:","category":"page"},{"location":"tutorials/latexinline/","page":"latexinline","title":"latexinline","text":"x - fracyz","category":"page"},{"location":"tutorials/latexinline/","page":"latexinline","title":"latexinline","text":"Among the supported types are:","category":"page"},{"location":"tutorials/latexinline/","page":"latexinline","title":"latexinline","text":"Expressions,\nStrings,\nNumbers (including rational and complex),\nSymbols,\nSymbolic expressions from SymEngine.jl.\nParameterizedFunctions.","category":"page"},{"location":"tutorials/latexinline/","page":"latexinline","title":"latexinline","text":"It can also take arrays, which it recurses and latexifies the elements, returning an array of latex strings.","category":"page"},{"location":"tutorials/latexarray/#latexarray","page":"latexarray","title":"latexarray","text":"","category":"section"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"This functions takes a 1 or 2D array and spits out a latex array environment. For example:","category":"page"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"julia> arr = eye(Int,3)\njulia> print(latexarray(arr))\n\n\\begin{equation}\n\\left[\n\\begin{array}{ccc}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\\\\\n\\end{array}\n\\right]\n\\end{equation}","category":"page"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"which renders as:","category":"page"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"\\begin{equation} \\left[ \\begin{array}{ccc} 1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\\\\\n\\end{array} \\right] \\end{equation}","category":"page"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"latexraw() is called for each element of the input, individually. It therefore does not matter if the input array is of a mixed type.","category":"page"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"arr = [1.0, 2-3im, 3//4, :(x/(k_1+x)), \"e^(-k_b*t)\"]\nlatexarray(arr)","category":"page"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"renders as:","category":"page"},{"location":"tutorials/latexarray/","page":"latexarray","title":"latexarray","text":"\\begin{equation} \\left[ \\begin{array}{c} 1.0\\\\\n2-3\\textit{i}\\\\\n\\frac{3}{4}\\\\\n\\frac{x}{k{1} + x}\\\\\ne^{- k{b} \\cdot t}\\\\\n\\end{array} \\right] \\end{equation}","category":"page"},{"location":"tutorials/parameterizedfunctions/#Use-with-ParameterizedFunctions","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"","category":"section"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"In the latexalign tutorial I mentioned that one can use latexalign directly on a ParameterizedFunction. Here, I make a somewhat more convoluted and hard-to-read example (you'll soon se why):","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"using Latexify\nusing ParameterizedFunctions\ncopy_to_clipboard(true)\n\node = @ode_def positiveFeedback begin\n    dx = y*y*y/(k_y_x + y) - x - x\n    dy = x^n_x/(k_x^n_x + x^n_x) - y\nend k_y k_x n_x\n\nlatexify(ode)","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginalign\nfracdxdt = fracy cdot y cdot yk_y_x + y - x - x \nfracdydt = fracx^n_xk_x^n_x + x^n_x - y \nendalign","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"This is pretty nice, but there are a few parts of the equation which could be reduced. Using a keyword argument, you can utilise the SymEngine.jl to reduce the expression before printing.","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"latexify(ode, field=:symfuncs)","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginalign\nfracdxdt = -2 cdot x + fracy^3k_y_x + y \nfracdydt =  - y + fracx^n_xk_x^n_x + x^n_x \nendalign","category":"page"},{"location":"tutorials/parameterizedfunctions/#Side-by-side-rendering-of-multiple-system.","page":"Use with ParameterizedFunctions","title":"Side-by-side rendering of multiple system.","text":"","category":"section"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"A vector of ParameterizedFunctions will be rendered side-by-side:","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"ode2 = @ode_def negativeFeedback begin\n    dx = y/(k_y + y) - x\n    dy = k_x^n_x/(k_x^n_x + x^n_x) - y\nend k_y k_x n_x\n\nlatexify([ode, ode2])","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginalign\nfracdxdt  =  fracy cdot y cdot yk_y_x + y - x - x    fracdxdt  =  fracyk_y + y - x    \nfracdydt  =  fracx^n_xk_x^n_x + x^n_x - y    fracdydt  =  frack_x^n_xk_x^n_x + x^n_x - y    \nendalign","category":"page"},{"location":"tutorials/parameterizedfunctions/#Visualise-your-parameters.","page":"Use with ParameterizedFunctions","title":"Visualise your parameters.","text":"","category":"section"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"Another thing that I have found useful is to display the parameters of these functions. The parameters are usually in a vector, and if it is somewhat long, then it can be annoying to try to figure out which element belongs to which parameter. There are several ways to solve this. Here are two:","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"## lets say that we have some parameters\nparam = [3.4,5.2,1e-2]\nlatexify(ode.params, param)","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginalign\nk_y = 34 \nk_x = 52 \nn_x = 001 \nendalign","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"or","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"latexify([ode.params, param]; env=:array, transpose=true)","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginequation\nleft\nbeginarrayccc\nk_y  k_x  n_x \n34  52  001 \nendarray\nright\nendequation","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"signif.() is your friend if your parameters have more significant numbers than you want to see.","category":"page"},{"location":"tutorials/parameterizedfunctions/#Get-the-jacobian,-hessian,-etc.","page":"Use with ParameterizedFunctions","title":"Get the jacobian, hessian, etc.","text":"","category":"section"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"ParameterizedFunctions symbolically calculates the jacobian, inverse jacobian, hessian, and all kinds of goodness. Since they are available as arrays of symbolic expressions, which are latexifyable, you can render pretty much all of them.","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"latexify(ode.symjac)","category":"page"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"beginequation\nleft\nbeginarraycc\n-2  frac3 cdot y^2k_y_x + y - fracy^3left( k_y_x + y right)^2 \nfracx^-1 + n_x cdot n_xk_x^n_x + x^n_x - fracx^-1 + 2 cdot n_x cdot n_xleft( k_x^n_x + x^n_x right)^2  -1 \nendarray\nright\nendequation","category":"page"},{"location":"tutorials/parameterizedfunctions/#Available-options","page":"Use with ParameterizedFunctions","title":"Available options","text":"","category":"section"},{"location":"tutorials/parameterizedfunctions/","page":"Use with ParameterizedFunctions","title":"Use with ParameterizedFunctions","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :ParameterizedFunction in arg.types || :Any in arg.types]\nlatexify(args, env=:mdtable, types=false)","category":"page"},{"location":"tutorials/rendering_latex/#A-note-on-rendering-\\LaTeX","page":"A note on rendering LaTeX","title":"A note on rendering LaTeX","text":"","category":"section"},{"location":"tutorials/rendering_latex/","page":"A note on rendering LaTeX","title":"A note on rendering LaTeX","text":"Using the print function on a latexified object prints text which is suitable for copy-pasting into a LaTeX document.","category":"page"},{"location":"tutorials/rendering_latex/","page":"A note on rendering LaTeX","title":"A note on rendering LaTeX","text":"However, it is often also useful to be able to render the equation inside the document that one is using to develop code. The Julia REPL does not support this, but IJulia does. So, inside a Jupyter document (or if you are running Atom with Hydrogen), you can render LaTeX using","category":"page"},{"location":"tutorials/rendering_latex/","page":"A note on rendering LaTeX","title":"A note on rendering LaTeX","text":"display(\"text/latex\", x)","category":"page"},{"location":"tutorials/rendering_latex/","page":"A note on rendering LaTeX","title":"A note on rendering LaTeX","text":"where x is a latex-formatted string.","category":"page"},{"location":"tutorials/rendering_latex/","page":"A note on rendering LaTeX","title":"A note on rendering LaTeX","text":"This requires x to specify a LaTeX environment. latexalign and latexequation already does this, but if you want to render the result of latexify you must supply an environment (for example \"\\$ $x \\$\").","category":"page"},{"location":"tutorials/DiffEqBiological/#Use-with-@reaction_network-from-DiffEqBiological.jl.","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"","category":"section"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"Latexify.jl has methods for dealing with AbstractReactionNetworks. For more information regarding this DSL, turn to its docs. The latexify end of things are pretty simple: feed a reaction network to latexify() and let it do its magic.","category":"page"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"using DiffEqBiological\nusing Latexify\ncopy_to_clipboard(true)\n\n@reaction_func hill2(x, v, k) = v*x^2/(k^2 + x^2)\n\nrn = @reaction_network MyRnType begin\n  hill2(y, v_x, k_x), 0 --> x\n  p_y, 0 --> y\n  (d_x, d_y), (x, y) --> 0\n  (r_b, r_u), x â†” y\nend v_x k_x p_y d_x d_y r_b r_u\n\nlatexify(rn)","category":"page"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"beginalign\nfracdxdt = fracv_x cdot y^2k_x^2 + y^2 - d_x cdot x - r_b cdot x + r_u cdot y \nfracdydt = p_y - d_y cdot y + r_b cdot x - r_u cdot y \nendalign","category":"page"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"The method has a keyword for choosing between outputting the ODE or the noise term. While it is not obvious from the latexify output, the noise in the reaction network is correlated.","category":"page"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"latexify(rn; noise=true)","category":"page"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"beginalign\nfracdxdt = sqrtfracv_x cdot y^2k_x^2 + y^2 - sqrtd_x cdot x - sqrtr_b cdot x + sqrtr_u cdot y \nfracdydt = sqrtp_y - sqrtd_y cdot y + sqrtr_b cdot x - sqrtr_u cdot y \nendalign","category":"page"},{"location":"tutorials/DiffEqBiological/#Chemical-arrow-notation","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Chemical arrow notation","text":"","category":"section"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"DiffEqBiologicals reaction network is all about chemical arrow notation, so why should we not be able to render arrows?","category":"page"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"Use latexify's env keyword argument to specify that you want :chemical (or the equivalent :arrow, :arrows or :chem).","category":"page"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"latexify(rn; env=:chemical)","category":"page"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"\\begin{align} \\require{mhchem} \\ce{ \\varnothing &->[\\frac{v{x} \\cdot y^{2}}{k{x}^{2} + y^{2}}] x}\\\\\n\\ce{ \\varnothing &->[p{y}] y}\\\\\n\\ce{ x &->[d{x}] \\varnothing}\\\\\n\\ce{ y &->[d{y}] \\varnothing}\\\\\n\\ce{ x &<=>[{r{b}}][{r_{u}}] y}\\\\\n\\end{align}","category":"page"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"The default output is meant to be rendered directly on the screen. This rendering is typically done by MathJax. To get the chemical arrow notation to render automatically, I have included a MathJax command (\\require{mhchem}) in the output string. If you want to use the output in a real LaTeX document, you can pass the keyword argument mathjax=false and this extra command will be omitted. In such case you should also add \\usepackage{mhchem} to the preamble of your latex document.","category":"page"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"Another keyword argument that may be of use is expand=false (defaults to true). This determines whether your functions should be expanded or not. Also, starred=true will change the outputted latex environment from align to align*. This results in the equations not being numbered.","category":"page"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"latexify(rn; env=:chemical, expand=false, starred=true)","category":"page"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"beginalign*\nrequiremhchem\nce varnothing -mathrmhill2left( y v_x k_x right) x\nce varnothing -p_y y\nce x -d_x varnothing\nce y -d_y varnothing\nce x =r_br_u y\nendalign*","category":"page"},{"location":"tutorials/DiffEqBiological/#Available-options","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Available options","text":"","category":"section"},{"location":"tutorials/DiffEqBiological/#Align","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Align","text":"","category":"section"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if (:ReactionNetwork in arg.types || :Any in arg.types) && :align in arg.env]\nlatexify(args, env=:mdtable, types=false)","category":"page"},{"location":"tutorials/DiffEqBiological/#Arrow-notation","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Arrow notation","text":"","category":"section"},{"location":"tutorials/DiffEqBiological/","page":"Use with @reaction_network from DiffEqBiological.jl.","title":"Use with @reaction_network from DiffEqBiological.jl.","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if (:ReactionNetwork in arg.types || :Any in arg.types) && :arrow in arg.env]\nlatexify(args, env=:mdtable, types=false)","category":"page"},{"location":"tutorials/latexalign/#latexalign","page":"latexalign","title":"latexalign","text":"","category":"section"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"This function converts its input to LaTeX align environments. One way of using the function is to pass it two vectors, one which holds the left-hand-side of the equations and the other which holds the right. For example:","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"lhs = [\"dx/dt\", \"dy/dt\"]\nrhs = [\"y^2 - x\", \"x/y - y\"]\nprint(latexalign(lhs, rhs))","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"outputs:","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"\\begin{align}\n\\frac{dx}{dt} =& y^{2} - x \\\\\n\\frac{dy}{dt} =& \\frac{x}{y} - y \\\\\n\\end{align}","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"In Jupyter, this can be rendered by:","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"display( latexalign(lhs, rhs))","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"\\begin{align*} \\frac{dx}{dt} =& y^{2} - x \\\\\n\\frac{dy}{dt} =& \\frac{x}{y} - y \\\\\n\\end{align*}","category":"page"},{"location":"tutorials/latexalign/#Using-DifferentialEquations.jl","page":"latexalign","title":"Using DifferentialEquations.jl","text":"","category":"section"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"The motivation for creating this function was mainly to be able to render ODEs. In my own work, I tend to use DifferentialEquations.jl to define ODEs as ParameterizedFunctions. Therefore, I found it useful to create a method which simply takes the ParameterizedFunction as input:","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"using Latexify\nusing DifferentialEquations\node = @ode_def positiveFeedback begin\n    dx = y/(k_y + y) - x\n    dy = x^n_x/(k_x^n_x + x^n_x) - y\nend k_y k_x n_x\n\nlatexalign(ode)","category":"page"},{"location":"tutorials/latexalign/","page":"latexalign","title":"latexalign","text":"\\begin{align} \\frac{dx}{dt} =& \\frac{y}{k{y} + y} - x \\\\\n\\frac{dy}{dt} =& \\frac{x^{n{x}}}{k{x}^{n{x}} + x^{n_{x}}} - y \\\\\n\\end{align}","category":"page"},{"location":"tutorials/inner_workings/#Inner-workings","page":"Inner workings","title":"Inner workings","text":"","category":"section"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"This package contains a large number of methods, but two of these are of special importance. These are:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"latexraw(ex::Expr)","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"and","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"latexoperation(ex::Expr, prevOp::AbstractArray)","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"These two methods are involved with all conversions to LaTeX equations. ","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"latexraw(ex::Expr) utilises Julias homoiconicity to infer the correct latexification of an expression by recursing through the expression tree. Whenever it hits the end of a recursion it passes the last expression to latexoperation(). By the nature of this recursion, this expression is one which only contains symbols or strings.","category":"page"},{"location":"tutorials/inner_workings/#Explanation-by-example","page":"Inner workings","title":"Explanation by example","text":"","category":"section"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"Let's define a variable of the expression type:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> ex = :(x + y/z)","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"This expression has a field which contains the first operation which must be done, along with the objects that this operation will operate on:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> ex.args\n\n3-element Array{Any,1}:\n :+      \n :x      \n :(y / z)","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"The first two element are both Symbols, while the third one is an expression:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> typeof.(ex.args)\n\n3-element Array{DataType,1}:\n Symbol\n Symbol\n Expr","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"Since at least one of these elements is an expression, the next step of the recursive algorithm is to dive into that expression:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> newEX = ex.args[3]\njulia> newEx.args\n\n3-element Array{Any,1}:\n :/\n :y\n :z","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"Since none of these arguments is another expression, newEx will be passed to latexoperation(). This function checks which mathematical operation is being done and converts newEx to an appropriately formatted string. In this case, that string will be \"\\\\frac{y}{z}\" (and yes, a double slash is needed).","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"newEx is now a string (despite its name):","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> newEx\n\n\"\\\\frac{y}{z}\"","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"The recursive latexraw() pulls this value back to the original expression ex, such that:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> ex.args\n\n3-element Array{Any,1}:\n :+      \n :x      \n :\"\\\\frac{y}{z}\"","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"Now, since this expression does not consist of any further expressions, it is passed to latexoperation(). The operator is now \"+\", and it should be applied on the second and third element of the expression, resulting in:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"\"x + \\\\frac{y}{z}\"","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"using the print function you get:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> print(latexraw(ex))\n\n\"x + \\frac{y}{z}\"","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"which in a LaTeX maths environment renders as:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"x + fracyz","category":"page"},{"location":"tutorials/inner_workings/#Extended-functionality","page":"Inner workings","title":"Extended functionality","text":"","category":"section"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"With the above example we can understand how an expression is converted to a LaTeX formatted string (unless my pedagogical skills are worse than I fear).","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"So, anything which can be converted to a Julia expression of the Expr type can be latexified. Luckily, since Julia needs to convert your code to expressions before it can be evaluated, Julia is already great at doing this.","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"There are already some methods for converting other types to expressions and passing them to the core method, for example:","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"latexraw(str::String) = latexraw(parse(str))","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"but if you find yourself wanting to parse some other type, it is often easy to overload the latexraw function.","category":"page"},{"location":"tutorials/inner_workings/#Latexifying-Arrays","page":"Inner workings","title":"Latexifying Arrays","text":"","category":"section"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"Also, if you pass an array to latexraw, it will recursively try to convert the elements of that array to LaTeX formatted strings.","category":"page"},{"location":"tutorials/inner_workings/","page":"Inner workings","title":"Inner workings","text":"julia> arr = [:(x-y/(k_10+z)), \"x*y*z/3\"]\njulia> latexraw(arr)\n2-element Array{String,1}:\n \"x - \\\\frac{y}{k_{10} + z}\"     \n \"\\\\frac{x \\\\cdot y \\\\cdot z}{3}\"\n\njulia> println.(latexraw(arr))\nx - \\frac{y}{k_{10} + z}\n\\frac{x \\cdot y \\cdot z}{3}","category":"page"},{"location":"functions/latexoperation/#latexoperation","page":"latexoperation","title":"latexoperation","text":"","category":"section"},{"location":"functions/latexoperation/","page":"latexoperation","title":"latexoperation","text":"This function is not exported.","category":"page"},{"location":"functions/latexoperation/","page":"latexoperation","title":"latexoperation","text":"DocTestSetup = quote\nusing Latexify\nusing DifferentialEquations\nend","category":"page"},{"location":"functions/latexoperation/","page":"latexoperation","title":"latexoperation","text":"Latexify.latexoperation","category":"page"},{"location":"functions/latexoperation/#Latexify.latexoperation","page":"latexoperation","title":"Latexify.latexoperation","text":"latexoperation(ex::Expr, prevOp::AbstractArray)\n\nTranslate a simple operation given by ex to LaTeX maths syntax. This uses the information about the previous operations to decide if a parenthesis is needed.\n\n\n\n\n\n","category":"function"},{"location":"functions/latexoperation/","page":"latexoperation","title":"latexoperation","text":"DocTestSetup = nothing","category":"page"},{"location":"tutorials/latexify/#latexify","page":"latexify","title":"latexify","text":"","category":"section"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"This is a wrapper of some of the other latexXXX functions. It tries to infer a suitable output mode for the given input. If the environment you are using supports the MIME type \"text/latex\", then the output will be rendered nicely.","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"using Latexify\ncopy_to_clipboard(true)\n\nex = :(x/y)\nlatexify(ex)\n","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"fracxy","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"If you print the output rather than display, then you will enforce the print-out of a string which is ready for some copy-pasting into your LaTeX document.","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"println(latexify(ex))\n\n## or the equivalent:\nlatexify(ex) |> println","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"$\\frac{x}{y}$","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"A matrix, or a single vector, is turned into an array.","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"M = signif.(rand(3,4), 2)\n\nlatexify(M)","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"\\begin{equation} \\left[ \\begin{array}{cccc} 0.85 & 0.99 & 0.85 & 0.5\\\\\n0.59 & 0.061 & 0.77 & 0.48\\\\\n0.7 & 0.17 & 0.7 & 0.82\\\\\n\\end{array} \\right] \\end{equation}","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"You can transpose the output using the keyword argument transpose=true.","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"If you give two vectors as an argument, they will be displayed as the left-hand-side and right-hand-side of an align environment:","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"latexify([\"x/y\", :z], Any[2.3, 1//2])","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"\\begin{align} \\frac{x}{y} =& 2.3 \\\\\nz =& \\frac{1}{2} \\\\\n\\end{align}","category":"page"},{"location":"tutorials/latexify/","page":"latexify","title":"latexify","text":"If you input a ParameterizedFunction or a ReactionNetwork from DifferentialEquations.jl you will also get an align environment. For more on this, have a look on their respective sections.","category":"page"},{"location":"tutorials/recipes/#Recipes","page":"Recipes","title":"Recipes","text":"","category":"section"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"Recipes provides a concise means of extending Latexify.jl to work with types of your own making or of other packages. The @latexrecipe macro allows you to specify how a an argument type (or a set of types) should be pre-processed before they are passed to the standard latexify function. Also, it allows you to define both new keyword arguments as well as to set the defaults of pre-existing ones. The main power of this macro is that is defines the necessary functions within Latexify.jl itself, as opposed to within the module where it is called. ","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"The recipe syntax closely follow that of the Plots.jl recipes and, indeed, most of the code is copied and adapted from them (cred to the authors!). ","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"So. The easiest way to explain it is by showing an example where we define a recipe for our type MyType. ","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"using Latexify\n\nstruct MyType \n   vector::Vector\nend","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"@latexrecipe function f(x::MyType; reverse=false)\n    ## we can access the input object and perform operations like in a normal function.\n    vec = x.vector\n    if reverse\n        vec = vec[end:-1:1]\n    end\n\n    ## we can define defult keyword arguments to be passed along to latexify \n    ## using an arrow notation, --> \n    env --> :array\n    transpose --> true\n    ## These can be overridden by the keyword arguments passed to the latexify function.\n\n    ## If you use the := operator to specify a value it cannot be overridden.\n    fmt := \"%.2f\"\n\n    ## The return value should be something that latexify already knows how to work with.\n    ## In this case, we have a simple vector which is fine!\n    return vec\nend","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"mytype = MyType([1, 2, 3])\n\nlatexify(mytype; reverse=true)","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"beginequation\nleft\nbeginarrayc\n300 \n200 \n100 \nendarray\nright\nendequation","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"The required signature of the macro is","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"@latexrecipe function f(x::MyType, ...; ...)\n    return something\nend","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"Here, the function name is unimportant, but the type signature is key.  There must also be an explicit return statement which returns something that  base Latexify already works with (Arrays, Tuples, Numbers, Symbols, Strings, etc.). In particular, you can not rely on Julia's default to return the value of the  last expression evaluated in a function body.","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"The special notation kwarg --> value resets the default value of a keyword argument for your specific inputs. This will be overridden if the keyword argument in quesion is specified in a call to latexify.  To disallow this overriding, use kwarg := value instead.","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"The use of @latexrecipe to redefine how an already supported type should be interpreted is highly discouraged. There is (currently) nothing in place to forbid this but it could mess up how latexify works with other packages. Disregarding this in your own sessions is one thing, but doing it in a package could cause very difficult issues for the users of your package. ","category":"page"},{"location":"tutorials/recipes/","page":"Recipes","title":"Recipes","text":"If a recipe is defined within a module, everything should just work without the need to export anything. ","category":"page"},{"location":"tutorials/latextabular/#latextabular","page":"latextabular","title":"latextabular","text":"","category":"section"},{"location":"tutorials/latextabular/","page":"latextabular","title":"latextabular","text":"using Latexify\ncopy_to_clipboard(true)\narr = [\"x/y\" :(y^n); 1.0 :(alpha(x))]\nlatextabular(arr) |> println","category":"page"},{"location":"tutorials/latextabular/","page":"latextabular","title":"latextabular","text":"outputs:","category":"page"},{"location":"tutorials/latextabular/","page":"latextabular","title":"latextabular","text":"\\begin{tabular}{cc}\n$\\frac{x}{y}$ & $y^{n}$\\\\\n$1.0$ & $\\alpha\\left( x \\right)$\\\\\n\\end{tabular}","category":"page"},{"location":"tutorials/latextabular/","page":"latextabular","title":"latextabular","text":"Unfortunately, this does not render nicely in Markdown. But you get the point.","category":"page"},{"location":"tutorials/latextabular/","page":"latextabular","title":"latextabular","text":"latextabular takes two keywords, one for changing the adjustment of the columns (centered by default), and one for transposing the whole thing.","category":"page"},{"location":"tutorials/latextabular/","page":"latextabular","title":"latextabular","text":"latextabular(arr; adjustment=:l, transpose=true) |> println","category":"page"},{"location":"tutorials/latextabular/","page":"latextabular","title":"latextabular","text":"\\begin{tabular}{ll}\n$\\frac{x}{y}$ & $1.0$\\\\\n$y^{n}$ & $\\alpha\\left( x \\right)$\\\\\n\\end{tabular}","category":"page"},{"location":"functions/latexalign/#latexalign","page":"latexalign","title":"latexalign","text":"","category":"section"},{"location":"functions/latexalign/","page":"latexalign","title":"latexalign","text":"DocTestSetup = quote\nusing Latexify\nusing DifferentialEquations\nend","category":"page"},{"location":"functions/latexalign/","page":"latexalign","title":"latexalign","text":"latexalign","category":"page"},{"location":"functions/latexalign/#Latexify.latexalign","page":"latexalign","title":"Latexify.latexalign","text":"latexalign()\n\nGenerate a LaTeX align environment from an input.\n\nExamples\n\nuse with arrays\n\nlhs = [:(dx/dt), :(dy/dt), :(dz/dt)]\nrhs = [:(y-x), :(x*z-y), :(-z)]\nlatexalign(lhs, rhs)\n\n\\begin{align}\n\\frac{dx}{dt} =& y - x \\\\\\\\\n\\frac{dy}{dt} =& x \\cdot z - y \\\\\\\\\n\\frac{dz}{dt} =& - z \\\\\\\\\n\\end{align}\n\nuse with ParameterizedFunction\n\njulia> using DifferentialEquations\njulia> ode = @ode_def foldChangeDetection begin\n    dm = r_m * (i - m)\n    dy = r_y * (p_y * i/m - y)\nend i r_m r_y p_y\n\njulia> latexalign(ode)\n\n\\begin{align}\n\\frac{dm}{dt} =& r_{m} \\cdot \\left( i - m \\right) \\\\\\\\\n\\frac{dy}{dt} =& r_{y} \\cdot \\left( \\frac{p_{y} \\cdot i}{m} - y \\right) \\\\\\\\\n\\end{align}\n\n\n\n","category":"function"},{"location":"functions/latexalign/","page":"latexalign","title":"latexalign","text":"DocTestSetup = nothing","category":"page"},{"location":"arguments/#List-of-possible-arguments","page":"List of possible arguments","title":"List of possible arguments","text":"","category":"section"},{"location":"arguments/#Align","page":"List of possible arguments","title":"Align","text":"","category":"section"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :align in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Equation","page":"List of possible arguments","title":"Equation","text":"","category":"section"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :equation in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Array","page":"List of possible arguments","title":"Array","text":"","category":"section"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :array in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Tabular","page":"List of possible arguments","title":"Tabular","text":"","category":"section"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :tabular in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Markdown-Table","page":"List of possible arguments","title":"Markdown Table","text":"","category":"section"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :mdtable in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Inline-and-raw","page":"List of possible arguments","title":"Inline and raw","text":"","category":"section"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :raw in arg.env || :inline in arg.env]\nlatexify(args, env=:mdtable)","category":"page"},{"location":"arguments/#Chemical-arrow-notation","page":"List of possible arguments","title":"Chemical arrow notation","text":"","category":"section"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Available with ReactionNetworks from DiffEqBiological.","category":"page"},{"location":"arguments/","page":"List of possible arguments","title":"List of possible arguments","text":"Base.include(@__MODULE__, \"src/table_generator.jl\")\nargs = [arg for arg in keyword_arguments if :arrow in arg.env]\nlatexify(args, env=:mdtable, types=false)","category":"page"},{"location":"#Latexify.jl","page":"Latexify.jl","title":"Latexify.jl","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Latexify.jl is a package which supplies functions for producing LaTeX  formatted strings from Julia objects. The package allows for latexification of a many different kinds of Julia object and it can output several different LaTeX or Markdown environments.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"A small teaser:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"using Latexify\ncopy_to_clipboard(false) # hide\nLatexify.set_default(; starred=true)\nm = [2//3 \"e^(-c*t)\" 1+3im; :(x/(x+k_1)) \"gamma(n)\" :(log10(x))]\nlatexify(m)","category":"page"},{"location":"#Supported-input","page":"Latexify.jl","title":"Supported input","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"This package supplies functionality for latexifying objects of the following types:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Expressions,\nStrings,\nNumbers (including rational and complex),\nMissing,\nSymbols,\nSymbolic expressions from SymEngine.jl,\nDataFrame from DataFrames.jl,\nAny shape of array containing a mix of any of the above types,\nParameterizedFunctions from DifferentialEquations.jl,\nReactionNetworks from DifferentialEquations.jl","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Example:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"str = \"x/(2*k_1+x^2)\"\nlatexify(str)","category":"page"},{"location":"#Supported-output","page":"Latexify.jl","title":"Supported output","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Latexify has support for generating a range of different LaTeX environments. The main function of the package, latexify(), automatically picks a suitable output environment based on the type(s) of the input. However, you can override this by passing the keyword argument env =. The following environments are available:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"environment env= description\nno env :raw Latexifies an object and returns a LaTeX formatted string. If the input is an array it will be recursed and all its elements latexified. This function does not surround the resulting string in any LaTeX environments.\nInline :inline latexify the input and surround it with $ for inline rendering.\nAlign :align Latexifies input and surrounds it with an align environment. Useful for systems of equations and such fun stuff.\nEquation :equation or :eq Latexifies input and surrounds it with an equation environment.\nArray :array Latexify the elements of an Array or a Dict and output them in a LaTeX array.\nTabular :table or :tabular Latexify the elements of an array and output a tabular environment. Note that tabular is not supported by MathJax and will therefore not be rendered in Jupyter, etc.\nMarkdown Table :mdtable Output a Markdown table. This will be rendered nicely by Jupyter, etc.\nMarkdown Text :mdtext Output and render any string which can be parsed into Markdown. This is really nothing but a call to Base.Markdown.parse(),  but it does the trick. Useful for rendering bullet lists and such things.\nChemical arrow notation :chem, :chemical, :arrow or :arrows Latexify an AbstractReactionNetwork to LaTeX formatted chemical arrow notation using mhchem.","category":"page"},{"location":"#Modifying-the-output","page":"Latexify.jl","title":"Modifying the output","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Some of the different outputs can be modified using keyword arguments. You can for example transpose an array with transpose=true or specify a header of a table or mdtable with header=[]. For more options, see the List of possible arguments.","category":"page"},{"location":"#Printing-vs-displaying","page":"Latexify.jl","title":"Printing vs displaying","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify() returns a LaTeXString. Using display() on such a string will try to render it.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(\"x/y\") |> display","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"fracxy","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Using print() will output text which is formatted for latex.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(\"x/y\") |> print","category":"page"},{"location":"#Number-formatting","page":"Latexify.jl","title":"Number formatting","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"You can control the formatting of numbers by passing any of the following to the fmt keyword:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"a printf-style formatting string, for example fmt = \"%.2e\".\na single argument function, for example fmt = x -> round(x, sigdigits=2).\na formatter supplied by Latexify.jl, for example fmt = FancyNumberFormatter(2) (thanks to @simeonschaub). You can pass any of these formatters an integer argument which specifies how many significant digits you want.\nFancyNumberFormatter() replaces the exponent notation, from 1.2e+3 to 1.2 \\cdot 10^3. \nStyledNumberFormatter() replaces the exponent notation, from 1.2e+3 to 1.2 \\mathrm{e} 3.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Examples:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(12345.678; fmt=\"%.1e\")","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"12e+04","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify([12893.1 1.328e2; \"x/y\" 7832//2378]; fmt=FancyNumberFormatter(3))","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"beginequation\nleft\nbeginarraycc\n129 cdot 10^4  133 \nfracxy  frac39161189 \nendarray\nright\nendequation","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"using Formatting\nlatexify([12893.1 1.328e2]; fmt=x->format(round(x, sigdigits=2), autoscale=:metric))","category":"page"},{"location":"#Automatic-copying-to-clipboard","page":"Latexify.jl","title":"Automatic copying to clipboard","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"The strings that you would see when using print on any of the above functions can be automatically copied to the clipboard if you so specify. Since I do not wish to mess with your clipboard without you knowing it, this feature must be activated by you.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"To do so, run","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"copy_to_clipboard(true)","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"To once again disable the feature, pass false to the same function.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"The copying to the clipboard will now occur at every call to a Latexify.jl function, regardless of how you chose to display the output.","category":"page"},{"location":"#Automatic-displaying-of-result","page":"Latexify.jl","title":"Automatic displaying of result","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"You can toggle whether the result should be automatically displayed. Instead of","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(\"x/y\") |> display\n## or\ndisplay( latexify(\"x/y\") )","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"one can toggle automatic display by:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"auto_display(true)","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"after which all calls to latexify will automatically be displayed. This can be rather convenient, but it can also cause a lot of unwanted printouts if you are using latexify in any form of loop. You can turn off this behaviour again by passing false to the same function.","category":"page"},{"location":"#Setting-your-own-defaults","page":"Latexify.jl","title":"Setting your own defaults","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"If you get tired of specifying the same keyword argument over and over in a session, you can just reset its default:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"set_default(fmt = \"%.2f\", convert_unicode = false)","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Note that this changes Latexify.jl from within and should therefore only be used in your own Julia sessions (do not call this from within your packages). ","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"The calls are additive so that a new call with ","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"set_default(cdot = false)","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"will not cancel out the changes we just made to fmt and convert_unicode. ","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"To view your changes, use","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"get_default()","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"and to reset your changes, use","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"reset_default()","category":"page"},{"location":"#Macros","page":"Latexify.jl","title":"Macros","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Three macros are exported. ","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"@latexify simply latexifies the expression that you provide to it, similar to latexify(:(...)).\n@latexrun both executes and latexifies the given expression. \n@latexdefine executes the expression, and latexifies the expression together with the its value","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"They can for example be useful for latexifying simple mathsy functions like","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"julia> lstr = @latexrun f(x; y=2) = x/y\nL\"$f\\left( x; y = 2 \\right) = \\frac{x}{y}$\"\n\njulia> f(1)\n0.5","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"julia> @latexdefine x = 1/2\nL\"$x = \\frac{1}{2} = 0.5\n\njulia> x\n0.5","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"The arguments to the macro can be interpolated with $ to use the actual value, instead of the representation:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"julia> @latexify x = abs2(-3)\nL\"$x = \\left|-3\\right|^{2}$\"\n\njulia> @latexify x = $(abs2(-3))\nL\"$x = 9$\"","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Keyword arguments can be supplied after these macros:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"julia> @latexdefine x env=:equation\nL\"\\begin{equation}\nx = 0.5\n\\end{equation}\n\"","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"A special keyword post can be supplied to @latexdefine, which is a function that will be called on the final right hand sign before latexification. This is merely formatting and will not affect any assignments.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"julia> @latexdefine x=Ï€  post=round\nL\"$x = \\pi = 3.0$\"\n\njulia> @latexdefine x\nL\"$x = \\pi$\"","category":"page"},{"location":"#External-rendering","page":"Latexify.jl","title":"External rendering","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"While LaTeXStrings already render nicely in many IDEs or in Jupyter, they do not render in the REPL. Therefore, we provide a function render(str) which generates a standalone PDF using LuaLaTeX and opens that file in your default PDF viewer.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"I have found the following syntax pretty useful:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(:(x/y)) |> render","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Alternatively, render(str, mime) can also be used to generate and display DVI, PNG and SVG files, which might be useful for other purposes:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"latexify(:(x/y)) |> s -> render(s, MIME(\"image/png\"))","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"PNG and SVG outputs rely on dvipng and dvisvgm, respectively.","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"If your code requires specific packages or document classes to render correctly, you can supply those as keyword arguments:","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"L\"\\qty{1.25}{nm}\" |> render(s, MIME(\"image/png\"); documentclass=\"article\", packages=(\"microtype\", (\"siunitx\", exponent-product=\"\\cdot\"))","category":"page"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"The arguments to these are either strings, or tuples of strings where the first one is the name of the package or class, and any further are optional arguments.","category":"page"},{"location":"#Legacy-support","page":"Latexify.jl","title":"Legacy support","text":"","category":"section"},{"location":"","page":"Latexify.jl","title":"Latexify.jl","text":"Latexify.jl has stopped supporting Julia versions older than 0.7. This does not mean that you cannot use Latexify with earlier versions, just that these will not get new features. Latexify.jl's release v0.4.1 was the last which supported Julia 0.6. Choose that release in the dropdown menu if you want to see that documentation.","category":"page"},{"location":"functions/latexify/#latexify","page":"latexify","title":"latexify","text":"","category":"section"},{"location":"functions/latexify/","page":"latexify","title":"latexify","text":"DocTestSetup = quote\nusing Latexify\nend","category":"page"},{"location":"functions/latexify/","page":"latexify","title":"latexify","text":"latexify","category":"page"},{"location":"functions/latexify/#Latexify.latexify","page":"latexify","title":"Latexify.latexify","text":"latexify(args...; kwargs...)\n\nLatexify a string, an expression, an array or other complex types.\n\njulia> latexify(\"x+y/(b-2)^2\")\nL\"$x + \\frac{y}{\\left( b - 2 \\right)^{2}}$\"\n\njulia> latexify(:(x/(y+x)^2))\nL\"$\\frac{x}{\\left( y + x \\right)^{2}}$\"\n\njulia> latexify([\"x/y\" 3//7 2+3im; 1 :P_x :(gamma(3))])\nL\"\\begin{equation}\n\\left[\n\\begin{array}{ccc}\n\\frac{x}{y} & \\frac{3}{7} & 2+3\\mathit{i} \\\\\n1 & P_{x} & \\Gamma\\left( 3 \\right) \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\"\n\n\n\n","category":"function"},{"location":"functions/latexify/","page":"latexify","title":"latexify","text":"DocTestSetup = nothing","category":"page"}]
}
