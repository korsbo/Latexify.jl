<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Inner workings · Latexify.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Latexify.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Latexify.jl</a></li><li><span class="toctext">Use with other packages</span><ul><li><a class="toctext" href="../parameterizedfunctions/">Use with ParameterizedFunctions</a></li><li><a class="toctext" href="../DiffEqBiological/">Use with @reaction_network from DiffEqBiological.jl.</a></li></ul></li><li><a class="toctext" href="../../arguments/">List of possible arguments</a></li><li class="current"><a class="toctext" href>Inner workings</a><ul class="internal"><li><a class="toctext" href="#Explanation-by-example-1">Explanation by example</a></li><li><a class="toctext" href="#Extended-functionality-1">Extended functionality</a></li><li><a class="toctext" href="#Latexifying-Arrays-1">Latexifying Arrays</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Inner workings</a></li></ul><a class="edit-page" href="https://github.com/korsbo/Latexify.jl/blob/master/docs/src/tutorials/inner_workings.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Inner workings</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Inner-workings-1" href="#Inner-workings-1">Inner workings</a></h1><p>This package contains a large number of methods, but two of these are of special importance. These are:</p><ul><li><code>latexraw(ex::Expr)</code></li></ul><p>and</p><ul><li><code>latexoperation(ex::Expr, prevOp::AbstractArray)</code></li></ul><p>These two methods are involved with all conversions to <span>$\LaTeX$</span> equations. </p><p><code>latexraw(ex::Expr)</code> utilises Julias homoiconicity to infer the correct latexification of an expression by recursing through the expression tree. Whenever it hits the end of a recursion it passes the last expression to <code>latexoperation()</code>. By the nature of this recursion, this expression is one which only contains symbols or strings.</p><h2><a class="nav-anchor" id="Explanation-by-example-1" href="#Explanation-by-example-1">Explanation by example</a></h2><p>Let&#39;s define a variable of the expression type:</p><pre><code class="language-julia-repl">julia&gt; ex = :(x + y/z)</code></pre><p>This expression has a field which contains the first operation which must be done, along with the objects that this operation will operate on:</p><pre><code class="language-julia-repl">julia&gt; ex.args

3-element Array{Any,1}:
 :+      
 :x      
 :(y / z)</code></pre><p>The first two element are both Symbols, while the third one is an expression:</p><pre><code class="language-julia-repl">julia&gt; typeof.(ex.args)

3-element Array{DataType,1}:
 Symbol
 Symbol
 Expr</code></pre><p>Since at least one of these elements is an expression, the next step of the recursive algorithm is to dive into that expression:</p><pre><code class="language-julia-repl">julia&gt; newEX = ex.args[3]
julia&gt; newEx.args

3-element Array{Any,1}:
 :/
 :y
 :z</code></pre><p>Since none of these arguments is another expression, <code>newEx</code> will be passed to <code>latexoperation()</code>. This function checks which mathematical operation is being done and converts newEx to an appropriately formatted string. In this case, that string will be &quot;\\frac{y}{z}&quot; (and yes, a double slash is needed).</p><p><code>newEx</code> is now a string (despite its name):</p><pre><code class="language-julia">julia&gt; newEx

&quot;\\frac{y}{z}&quot;</code></pre><p>The recursive <code>latexraw()</code> pulls this value back to the original expression <code>ex</code>, such that:</p><pre><code class="language-julia-repl">julia&gt; ex.args

3-element Array{Any,1}:
 :+      
 :x      
 :&quot;\\frac{y}{z}&quot;</code></pre><p>Now, since this expression does not consist of any further expressions, it is passed to <code>latexoperation()</code>. The operator is now &quot;+&quot;, and it should be applied on the second and third element of the expression, resulting in:</p><pre><code class="language-julia">&quot;x + \\frac{y}{z}&quot;</code></pre><p>using the print function you get:</p><pre><code class="language-julia-repl">julia&gt; print(latexraw(ex))

&quot;x + \frac{y}{z}&quot;</code></pre><p>which in a <span>$\LaTeX$</span> maths environment renders as:</p><div>\[x + \frac{y}{z}\]</div><h2><a class="nav-anchor" id="Extended-functionality-1" href="#Extended-functionality-1">Extended functionality</a></h2><p>With the above example we can understand how an expression is converted to a <span>$\LaTeX$</span> formatted string (unless my pedagogical skills are worse than I fear).</p><p>So, anything which can be converted to a Julia expression of the Expr type can be latexified. Luckily, since Julia needs to convert your code to expressions before it can be evaluated, Julia is already great at doing this.</p><p>There are already some methods for converting other types to expressions and passing them to the core method, for example:</p><pre><code class="language-julia">latexraw(str::String) = latexraw(parse(str))</code></pre><p>but if you find yourself wanting to parse some other type, it is often easy to overload the <code>latexraw</code> function.</p><h2><a class="nav-anchor" id="Latexifying-Arrays-1" href="#Latexifying-Arrays-1">Latexifying Arrays</a></h2><p>Also, if you pass an array to <code>latexraw</code>, it will recursively try to convert the elements of that array to <span>$\LaTeX$</span> formatted strings.</p><pre><code class="language-julia-repl">julia&gt; arr = [:(x-y/(k_10+z)), &quot;x*y*z/3&quot;]
julia&gt; latexraw(arr)
2-element Array{String,1}:
 &quot;x - \\frac{y}{k_{10} + z}&quot;     
 &quot;\\frac{x \\cdot y \\cdot z}{3}&quot;

julia&gt; println.(latexraw(arr))
x - \frac{y}{k_{10} + z}
\frac{x \cdot y \cdot z}{3}</code></pre><footer><hr/><a class="previous" href="../../arguments/"><span class="direction">Previous</span><span class="title">List of possible arguments</span></a></footer></article></body></html>
